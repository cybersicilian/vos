// @bun
var L;(function(Y){Y[Y["DECK"]=0]="DECK";Y[Y["TOP_DECK"]=1]="TOP_DECK";Y[Y["BOTTOM_DECK"]=2]="BOTTOM_DECK";Y[Y["RANDOM_DECK"]=3]="RANDOM_DECK";Y[Y["HAND"]=4]="HAND";Y[Y["DISCARD"]=5]="DISCARD";Y[Y["NONE"]=6]="NONE"})(L||(L={}));var S;(function(X){X[X["PLAYER"]=0]="PLAYER";X[X["OPPONENT"]=1]="OPPONENT";X[X["CARD_IN_HAND"]=2]="CARD_IN_HAND";X[X["CARD_IN_DISCARD"]=3]="CARD_IN_DISCARD";X[X["CARD"]=4]="CARD"})(S||(S={}));var W;(function(O){O[O["SELF"]=0]="SELF";O[O["OPPONENT_MOST_CARDS"]=1]="OPPONENT_MOST_CARDS";O[O["OPPONENT_LEAST_CARDS"]=2]="OPPONENT_LEAST_CARDS";O[O["OPPONENT_RANDOM"]=3]="OPPONENT_RANDOM";O[O["PLAYER_RANDOM"]=4]="PLAYER_RANDOM";O[O["PLAYER_MOST_CARDS"]=5]="PLAYER_MOST_CARDS";O[O["PLAYER_LEAST_CARDS"]=6]="PLAYER_LEAST_CARDS";O[O["CARD_IN_HAND_LEAST_POWER"]=7]="CARD_IN_HAND_LEAST_POWER";O[O["CARD_IN_HAND_MOST_POWER"]=8]="CARD_IN_HAND_MOST_POWER";O[O["CARD_IN_HAND_RANDOM"]=9]="CARD_IN_HAND_RANDOM";O[O["CARD_IN_DISCARD_LEAST_POWER"]=10]="CARD_IN_DISCARD_LEAST_POWER";O[O["CARD_IN_DISCARD_MOST_POWER"]=11]="CARD_IN_DISCARD_MOST_POWER";O[O["CARD_IN_DISCARD_RANDOM"]=12]="CARD_IN_DISCARD_RANDOM";O[O["OPPONENT_MOST_TURNS_REMAINING"]=13]="OPPONENT_MOST_TURNS_REMAINING";O[O["OPPONENT_LEAST_TURNS_REMAINING"]=14]="OPPONENT_LEAST_TURNS_REMAINING";O[O["PLAYER_MOST_TURNS_REMAINING"]=15]="PLAYER_MOST_TURNS_REMAINING";O[O["PLAYER_LEAST_TURNS_REMAINING"]=16]="PLAYER_LEAST_TURNS_REMAINING"})(W||(W={}));var I;(function(Y){Y[Y["BASIC"]=0]="BASIC";Y[Y["COMMON"]=1]="COMMON";Y[Y["UNCOMMON"]=2]="UNCOMMON";Y[Y["RARE"]=3]="RARE";Y[Y["MYTHIC"]=4]="MYTHIC";Y[Y["LEGENDARY"]=5]="LEGENDARY";Y[Y["HAXOR"]=6]="HAXOR"})(I||(I={}));class _{callback;cachedValue;value=!1;constructor($){if(this.callback=$,typeof $!=="function")this.value=!0,this.cachedValue=$}resolve(...$){if(this.value)return this.cachedValue;return this.callback(...$)}getCallback(){return this.callback}}class G{name;abilities=[];power=1;rarity=I.COMMON;canPlay=new _(!0);canGive=new _(!0);discardable=!0;zone=L.NONE;props={};constructor($,J){this.name=$,this.abilities=J}setZone($){return this.zone=$,this}remove($){this.move(L.NONE,$)}move($,J,K){let V=this.zone;switch(V){case L.DECK:J.deck.splice(J.deck.indexOf(this),1);break;case L.HAND:if(K&&K.from)K.from.cih().splice(K.from.cih().indexOf(this),1);else J.owner.cih().splice(J.owner.cih().indexOf(this),1);break;case L.DISCARD:J.deck.discardPile.splice(J.deck.discardPile.indexOf(this),1);break}if(this.fireEvents(`moveFrom_${Object.values(L)[V]}`,J),$!==L.NONE){switch($){case L.DECK:case L.RANDOM_DECK:J.deck.push(this),J.deck.shuffle();break;case L.TOP_DECK:J.deck.unshift(this);break;case L.BOTTOM_DECK:J.deck.push(this);break;case L.DISCARD:J.deck.discardPile.push(this);break;case L.HAND:if(K&&K.to)K.to.cih().push(this);else J.owner.cih().push(this);break}if(this.zone=$,this.zone===L.TOP_DECK||this.zone===L.BOTTOM_DECK||this.zone===L.RANDOM_DECK)this.zone=L.DECK;this.fireEvents(`moveTo_${Object.values(L)[this.zone]}`,J)}else this.zone=$}setCanPlay($){return this.canPlay=new _($),this}setCanGive($){return this.canGive=new _($),this}setProps($){return this.props=$,this}setProp($,J,K){return this.props[$]=J,this}addAbility($){return this.abilities.push($),this}getChoices($){return this.orderAbilities().map((J)=>{return J.informChoices({...$,card:this})}).flat()}skipDiscard(){return this.discardable=!1,this}doSkipDiscard(){return!this.discardable}getProps(){return{...this.props}}getProp($){return this.getProps()[$]}clone(){let $=new G(this.name,this.abilities.map((J)=>J.clone()));return $.setPow(this.power),$.setRarity(this.rarity),$.setCanPlay(this.canPlay.getCallback()),$.setCanGive(this.canGive.getCallback()),$.setProps({...this.props}),$}canBePlayed($){if(this.abilities.map((K)=>K.canBePlayed($)).includes(!1))return!1;return this.canPlay.resolve($)}canBeGiven($,J){if(this.abilities.map((V)=>V.canBeGiven($,J)).includes(!1))return!1;return this.canGive.resolve($,J)}setRarity($){return this.rarity=$,this}getRarity(){return this.rarity}getAbilities(){return this.abilities}getDisplayName(){let $="";if(this.pow()!==1){if(this.pow()>1)$=` +${this.pow()-1}`;else if(this.pow()<1)$=` ${this.pow()-1}`}return this.getName()+$}getName(){return this.name}setName($){return this.name=$,this}toState($){let J={...this.getProps()};return delete J.deck,{name:this.getDisplayName(),text:this.getFormulatedText($),rarity:this.getRarity(),power:this.pow(),formula:this.getFormulas(),props:J,playable:this.canBePlayed({owner:$.owner,opps:$.opps,deck:$.deck,card:this})}}toCardState(){let $={...this.getProps()};return delete $.deck,{name:this.name,power:this.power,rarity:this.rarity,text:this.getText(),props:$}}getLogText(){return`\xA7\xA7${this.name}\xA7card\xA7${JSON.stringify(this.toCardState())}\xA7\xA7`}pow(){return Math.min(this.power,999)}setPow($){if(this.power=$,this.power>999)this.power=999;return this}explode($){this.move(L.NONE,$);let J=[];if(this.getProp("fragment"))return J;else{let K=1;for(let V of this.orderAbilities()){let Q=new G(`${this.getName()} Fragment #${K}`,[V.clone()]).setPow(this.pow()).setRarity(this.getRarity()).setProps({...this.props});Q.setProp("fragment",!0),K++,J.push(Q)}return J}}onSlottable($){for(let J of this.orderAbilities())if(J.getProp("slotted_ability"))J.onSlot($)}orderAbilities(){return this.abilities.sort(($,J)=>{if($.constructor.name==="CostAbility"&&J.constructor.name!=="CostAbility")return-1;else if($.constructor.name!=="CostAbility"&&J.constructor.name==="CostAbility")return 1;else if($.constructor.name==="PlayerRestrictionAbility"&&J.constructor.name!=="PlayerRestrictionAbility")return-1;else if($.constructor.name!=="PlayerRestrictionAbility"&&J.constructor.name==="PlayerRestrictionAbility")return 1;else if($.constructor.name==="PlayerRestrictionAbilityNeg"&&J.constructor.name!=="PlayerRestrictionAbilityNeg")return-1;else if($.constructor.name!=="PlayerRestrictionAbilityNeg"&&J.constructor.name==="PlayerRestrictionAbilityNeg")return 1;else if($.constructor.name==="PlayerPredicateRestrictionAbility"&&J.constructor.name!=="PlayerPredicateRestrictionAbility")return-1;else if($.constructor.name!=="PlayerPredicateRestrictionAbility"&&J.constructor.name==="PlayerPredicateRestrictionAbility")return 1;else if($.hasRestriction()&&!J.hasRestriction())return-1;else if(!$.hasRestriction()&&J.hasRestriction())return 1;else if($.getProp("slotted_ability")&&!J.getProp("slotted_ability"))return 1;else if(!$.getProp("slotted_ability")&&J.getProp("slotted_ability"))return-1;return 0})}fireEvents($,J){for(let K of this.orderAbilities())K.fireEvents($,J)}play($,J,K,V){let Q=0;if(this.canBePlayed({owner:$,opps:J,deck:K,card:this}))for(let X of this.orderAbilities()){let j=V?V[Q]:void 0;X.fireEvents("play",{owner:$,opps:J,deck:K,card:this,choices:j}),Q++}}draw($,J,K){for(let V of this.orderAbilities())V.fireEvents("draw",{owner:$,opps:J,deck:K,card:this})}give($,J,K){for(let V of this.orderAbilities())V.fireEvents("give",{owner:$,opps:J,deck:K,card:this})}discard($,J,K){for(let V of this.orderAbilities())V.fireEvents("discard",{owner:$,opps:J,deck:K,card:this})}getText(){return this.orderAbilities().map((J)=>J.getText()).join("\n")}getFormulatedText($){return this.orderAbilities().map((K)=>K.getFormulatedText($)).join("\n")}getFormulas(){return this.orderAbilities().map((J)=>{if(J.hasFormula())return J.getFormula();return""})}getTraits($){let K=this.orderAbilities().map((Q)=>{return Q.ai()}),V={profile:{}};for(let Q of K)for(let X of Object.keys(Q)){let j=new _(Q[X]).resolve($);if(V.profile[X])V.profile[X]+=j;else V.profile[X]=j}return V}static combine(...$){let J=$.map((Q)=>Q.clone()),K=new G(J.map((Q)=>Q.getName()).join(" + "),[...J.map((Q)=>Q.getAbilities()).flat()]);K.setPow(Math.floor(J.map((Q)=>Q.pow()).reduce((Q,X)=>Q+X,0)/J.length)),K.setRarity(Math.floor(J.map((Q)=>Q.getRarity()).reduce((Q,X)=>Q+X,0)/J.length)),K.setCanPlay((Q)=>{for(let X of J)if(!X.canBePlayed(Q))return!1;return!0});let V={};for(let Q of J)V={...V,...Q.getProps()};return K.setProps(V),K}}var X0={Jesse:{collectResource:10,spendResource:-15,affectsSelf:5,affectsOpponents:20,changesGame:5,meme:10,oppWinSetback:50,discardOpponentCards:10},Ian:{collectResource:20,spendResource:10,drawsCards:10,changesGame:10,affectsSelf:15,discardsCards:-10,unlockUpgrades:10}},T=X0;class E{optimality=1;profile={};profileName="";constructor($=""){if(T[$])this.profileName=$;else this.profileName=Object.keys(T)[Math.floor(Math.random()*Object.keys(T).length)];this.profile=T[this.profileName]}getProfileName(){return this.profileName}getProfile(){return this.profile}static makeSpecificChoice($,J){let K=[];if(J.pointer instanceof Function)K.push(J.pointer($));else switch(J.pointer){case W.SELF:K.push($.owner);break;case W.OPPONENT_MOST_CARDS:K.push(...$.opps.sort((Q,X)=>X.inHand()-Q.inHand()));break;case W.OPPONENT_LEAST_CARDS:K.push(...$.opps.sort((Q,X)=>Q.inHand()-X.inHand()));break;case W.OPPONENT_RANDOM:let V=$.opps.sort(()=>Math.random()-0.5);K.push(...V);break;case W.CARD_IN_DISCARD_LEAST_POWER:K.push(...$.deck.discardPile.sort((Q,X)=>{if(!Q||!X)return 0;return Q.pow()-X.pow()}));break;case W.CARD_IN_DISCARD_MOST_POWER:K.push(...$.deck.discardPile.sort((Q,X)=>{if(!Q||!X)return 0;return X.pow()-Q.pow()}));break;case W.CARD_IN_DISCARD_RANDOM:K.push(...$.owner.cih().sort(()=>Math.random()-0.5));break;case W.CARD_IN_HAND_LEAST_POWER:K.push(...$.owner.cih().sort((Q,X)=>{if(!Q||!X)return 0;return Q.pow()-X.pow()}));break;case W.CARD_IN_HAND_MOST_POWER:K.push(...$.owner.cih().sort((Q,X)=>{if(!Q||!X)return 0;return X.pow()-Q.pow()}));break;case W.CARD_IN_HAND_RANDOM:K.push(...$.owner.cih().sort(()=>Math.random()-0.5));break;case W.PLAYER_RANDOM:K.push(...[$.owner,...$.opps].sort(()=>Math.random()-0.5));break;case W.PLAYER_MOST_CARDS:K.push(...[$.owner,...$.opps].sort((Q,X)=>X.inHand()-Q.inHand()));break;case W.PLAYER_LEAST_CARDS:K.push(...[$.owner,...$.opps].sort((Q,X)=>Q.inHand()-X.inHand()));break;case W.PLAYER_MOST_TURNS_REMAINING:K.push(...[$.owner,...$.opps].sort((Q,X)=>X.getTurns()-Q.getTurns()));break;case W.PLAYER_LEAST_TURNS_REMAINING:K.push(...[$.owner,...$.opps].sort((Q,X)=>Q.getTurns()-X.getTurns()));break;case W.OPPONENT_MOST_TURNS_REMAINING:K.push(...$.opps.sort((Q,X)=>X.getTurns()-Q.getTurns()));break;case W.OPPONENT_LEAST_TURNS_REMAINING:K.push(...$.opps.sort((Q,X)=>Q.getTurns()-X.getTurns()));break}return K}optimalityCrux($){let J=this.optimality,K=$.length,V=(X)=>{let j=2*K,Y=-(1-J)*X;return j*(1-1/(1+Math.E**Y))},Q=Math.random()*100;return $[Math.floor(V(Q))]}selectChoices($,J){if(!J.card)return[];else{let K=J.card.getChoices(J),V=[];for(let Q of K)V.push(this.optimalityCrux(E.makeSpecificChoice(J,Q)))}}evaluate($,J){let K=$.getTraits(J),V=0;for(let Q in K.profile)if(this.profile[Q])try{V+=K.profile[Q]*this.profile[Q]}catch{console.log(`Error evaluating card ${$.getName()} with weight ${Q}`)}return V}}class M{text;callback;choices=new _([]);formula="{pow}";canPlay=new _(!0);canGive=new _(!0);props={};events={};traits={};constructor($,J,K){this.text=$,this.callback=K,this.choices=new _(J),this.addEvent("play",(V)=>{this.exec(V)})}ai(){return this.traits}sai($,J){return this.traits={...$},this}isCostAbility(){return this.props.cost_ability??!1}clone(){let $=new M(this.text,this.choices.resolve(),this.callback);$.setFormula(this.formula),$.setCanPlay(this.canPlay.getCallback()),$.setCanGive(this.canGive.getCallback()),$.sai(this.ai());for(let J of Object.keys(this.props))$.setProp(J,this.props[J]);return $}getChoices(){return this.choices.resolve()}getCallback(){return this.callback}setCanPlay($){return this.canPlay=new _($),this}setCanGive($){this.canGive=new _($)}canBePlayed($){let J=this.choices.resolve($);if(J.length>0){for(let K of J)if(K.choice===S.OPPONENT){if($.opps.length===0)return!1}else if(K.choice===S.CARD_IN_DISCARD){if(!$.deck)return!1;if($.deck.discardPile.length===0)return!1}else if(K.choice===S.CARD_IN_HAND){if($.owner.cih().length<=1)return!1}}return this.canPlay.resolve($)}canBeGiven($,J){return this.canGive.resolve($,J)}setText($){return this.text=$,this}hasRestriction(){return typeof this.canPlay==="function"||!this.canPlay}getText(){return this.text.replace("{formula}",this.textualizeFormula())}getFormulatedText($){return this.text.replace("{formula}",this.calcFormula($))}informChoices($){return this.choices.resolve($)}setFormula($){return this.formula=$,this}textualizeFormula(){let $=this.formula;for(let J in this.props)$=$.replace(`{${J}}`,this.props[J]);return $}calcFormula($){let J=this.textualizeFormula();try{J=J.replace("{pow}",$.card.pow().toString())}catch{J=J.replace("{pow}","1")}return(0, eval)(J)}makeChoices($){let J=[];for(let K of this.informChoices($)){let V=E.makeSpecificChoice($,K),Q=0;if((K.restriction??((j)=>!0))($)||J.indexOf(V[Q])!==-1&&K.distinct)while(J.indexOf(V[Q])!==-1&&Q<V.length-1)Q++;if(Q>=V.length)J.push(null);J.push(V[Q])}return J}exec($){this.callback($,$.choices??this.makeChoices($))}on($,J){return this.addEvent($,J),this}addEvent($,J){if(!this.events[$])this.events[$]=[];this.events[$].push(J)}removeEvent($){if(this.events[$])delete this.events[$];return this}getEvent($){return this.events[$]}hasFormula(){return this.text.indexOf("{formula}")!==-1}getFormula(){return this.formula}fireEvents($,J){if(this.events[$])for(let K of this.events[$])K(J);if(this.events[`temp_${$}`]){for(let K of this.events[`temp_${$}`])K(J);delete this.events[`temp_${$}`]}}getProps(){return this.props}getProp($){return this.props[$]}setProp($,J){return this.props[$]=J,this}}class m extends M{constructor($){super("Increase the power of a card in your hand by {formula}",[{choice:S.CARD_IN_HAND,pointer:W.CARD_IN_HAND_LEAST_POWER}],(J,K)=>{if(J.choices)J.choices[0].setPow(J.choices[0].pow()+$+J.card.pow())});this.sai({improvesCard:(J)=>{return(J?J.pow?J.pow():1:1)+$}}),this.setFormula(`{pow} + ${$}`)}}class o extends M{constructor($){super("Discard {formula} cards at random",[],(J,K)=>{for(let V=0;V<this.calcFormula(J);V++)J.owner.discardRandom(J)});this.sai({affectsSelf:(J)=>J.card.pow()+$,discardsCards:(J)=>J.card.pow()+$}),this.setFormula(`${$} - {pow}`)}}class t extends M{constructor(){super("Remove all other copies of this card from the game",[],($,J)=>{let K=$.opps.concat($.owner),V=[];for(let Q of K)V.push(...Q.cih().filter((X)=>{if(!X||!$.card)return!1;return X.getName()===$.card.getName()}));V.push(...$.deck.discardPile.filter((Q)=>{if(!Q||!$.card)return!1;return Q.getName()===$.card.getName()})),V.push(...$.deck.filter((Q)=>{if(!Q||!$.card)return!1;return Q.getName()===$.card.getName()})),V.forEach((Q)=>{Q.remove($)}),$.card.skipDiscard(),$.deck.shuffle()});this.sai({changesGame:1})}}class c extends M{constructor(){super("Explode a card in your hand. The new cards each have power {formula}.",[{choice:S.CARD_IN_HAND,distinct:!0,pointer:W.CARD_IN_HAND_MOST_POWER,restriction:($)=>{return!$.card.getProp("fragment")}}],($,J)=>{J[0].explode($).forEach((Q)=>{Q.move(L.HAND,$)})});this.sai({drawsCards:($)=>{return this.calcFormula($)},improvesCard:($)=>this.calcFormula($)})}}class C extends M{constructor($,J){super(`Add {formula} ${J}`,[],(K)=>{let V=this.calcFormula(K),Q=K.owner.getProp(`res_${J}`)??0;K.owner.setProp(`res_${J}`,Q+V,K)});if(this.setProp("resource",!0),!this.getProp("produce"))this.setProp("produce",[]);this.setProp("produce",[...this.getProp("produce"),J]),this.setFormula(`{pow} + ${$}`),this.sai({collectResource:$})}}class n extends M{constructor($,J=75,K=!0,V=!1){super(`Add the ${$.replace("_"," ").replace(" deck","")} deck to the game${K?" if it hasn't been already.":""}`,[],(Q)=>{if(u[$]&&(!K||!Q.deck.props[`added_${$}`]))Q.deck.addCards(R.fromCardList(J,$)),Q.deck.shuffle()});if(K&&V)this.setCanPlay((Q)=>{return!Q.deck.props[`added_${$}`]});this.sai({addCardsToDeck:J,changesGame:1}),this.setProp("deck",!0)}}class P extends M{constructor(){super("Play only if you have 0 or less life",[],($)=>{});this.setCanPlay(($)=>{return $.owner.getProp("res_life")&&$.owner.getProp("res_life")<=0}),this.sai({},{pbp:["res_life"]})}}class d extends M{constructor($){super(`${$}`,[],(J)=>{});this.sai({meme:10})}}class g extends M{callbacks={};constructor($,J){super($,[],()=>{});this.callbacks=J,this.setProp("slotted_ability",!0)}onSlot($){if($.owner.addSlottedAbility(this),this.callbacks.onSlot)this.callbacks.onSlot($)}onUnslot($){if($.owner.removeSlottedAbility(this),this.callbacks.onUnslot)this.callbacks.onUnslot($)}playerEvents(){return this.callbacks.playerEvents??{}}clone(){let $=new g(this.text,this.callbacks);$.setFormula(this.formula),$.setCanPlay(this.canPlay.getCallback()),$.setCanGive(this.canGive.getCallback()),$.sai(this.ai());for(let J of Object.keys(this.props))$.setProp(J,this.props[J]);return $}}class i extends M{constructor($){super("Add {formula} turns..",[],(J,K)=>{J.owner.addTurns(Math.max(0,$-J.card?.pow()))});this.setFormula(`${$} - {pow}`),this.sai({winProgress:(J)=>Math.max($-J.card.pow(),0),affectsSelf:(J)=>Math.max($-J.card.pow(),0)})}}var f;(function(K){K["UPGRADE_SHOP"]="meta_upgrade";K["RELIGION"]="meta_slottable_religion"})(f||(f={}));var U0={zombie_deck:[new G("Chomp",[new P,new M("Deal {formula} damage to an opponent. They discard that many cards.",[{pointer:W.OPPONENT_MOST_CARDS,choice:S.OPPONENT}],($,J)=>{let K=J[0],V=$.card.pow()*5;if($.owner.getProp("res_life")<=0){K.setProp("res_life",K.getProp("res_life")-V,$);for(let Q=0;Q<V;Q++)K.discardChoose($)}}).setFormula("{pow} * 5")]).setRarity(I.COMMON),new G("Brain Munchies",[new P,new M("Draw {formula} cards.",[],($,J)=>{if($.owner.getProp("res_life")<=0)$.owner.draw($.deck,$.card.pow())}).setFormula("{pow} + 2")]).setRarity(I.COMMON),new G("X-49 Antigen",[new M("Play only if you aren't an antivaxxer.",[],($,J)=>{}).setCanPlay(($)=>{return!$.owner.getProp("antivaxxer")}),new M("Heal all zombies. They give you their hands out of gratitude.",[],($,J)=>{if(!$.owner.getProp("antivaxxer"))for(let K of $.opps)K.setProp("res_life",10,$),$.owner.setCiH($.owner.cih().concat(K.cih())),K.setCiH([])})]).setCanPlay(($)=>{return!$.owner.getProp("antivaxxer")}).setRarity(I.RARE),new G("Necromutation",[new P,new c,new m(2)]).setRarity(I.RARE),new G("Rot Brains",[new P,new M("Zombify half the cards in an opponents hand. (They can't play them unless they are a zombie)",[{choice:S.OPPONENT,pointer:W.OPPONENT_MOST_CARDS}],($,J)=>{let K=J[0],V=K.cih(),Q=Math.ceil(V.length/2),X=V.map((j,Y)=>j.clone()).sort(()=>Math.random()-0.5);for(let j=0;j<Q;j++)X[j]=new G(`Zombified ${X[j].getName()}`,[new P,...X[j].getAbilities()]).setPow(X[j].pow()).setRarity(X[j].getRarity()).setProps({zombie:!0,...X[j].getProps()}).setZone(L.HAND);K.setCiH(X)})])],faith_deck:[new G("Many-Armed One",[new n("faith_evangelical_deck",75,!0,!0).setText("Play only if the evangelical deck hasn't been added yet. Add the evangelical deck to the game."),new g("When you draw a card, gain 1 faith",{playerEvents:{draw:[($)=>{$.owner.addResource("faith",1)}]}})]).setProp(f.RELIGION,[0]).setRarity(I.BASIC),new G("Thoughts and Prayers",[new C(0,"faith"),new i(3).setText("Meditate. Add {formula} turns.")]).setRarity(I.COMMON),new G("Have You Heard the Good Message?",[new C(1,"faith"),new o(2).setText("Discard {formula} cards.")]).setRarity(I.COMMON)],poop_deck:[new G("Pile o' Crap",[new d("\uD83D\uDCA9")]).setRarity(I.BASIC).setProp("crap",!0)],basic:[new G("You Could Make a Religion Outta This",[new n("faith_deck"),new C(1,"faith"),new M("Everyone unlocks the ability to create a religion",[],($)=>{for(let J of[$.owner,...$.opps])J.setProp("religion",!0,$)}),new t]).setRarity(I.LEGENDARY)]},u=U0;class R extends Array{constructor(){super(...arguments)}discardPile=[];props={};set($){return this.splice(0,this.length,...$),this}asArray(){return this}addCard($,J=1){for(let K=0;K<J;K++)this.push($.clone().setZone(L.DECK));return this}addCards($){return this.push(...$.map((J)=>J.clone().setZone(L.DECK))),this}shuffle(){for(let $=this.length-1;$>0;$--){const J=Math.floor(Math.random()*$),K=this[$];this[$]=this[J],this[J]=K}}reshuffle(){this.push(...this.discardPile.map(($)=>$.setZone(L.DECK))),this.discardPile=[],this.shuffle()}draw($=1){let J=[];for(let K=0;K<$;K++){if(this.length===0)this.reshuffle();J.push(this.pop().setZone(L.HAND))}return J}static fromCardList($,J){let K=u[J],V={};for(let Y of K){if(!V[Y.getRarity()])V[Y.getRarity()]=0;V[Y.getRarity()]++}let Q={},X=0;for(let Y of Object.keys(V))Q[Y]=$*Math.pow(0.75,Object.keys(V).indexOf(Y)),X+=Q[Y];for(let Y of Object.keys(V))Q[Y]=Math.round(Q[Y]/X*$);let j=new R;for(let Y of K)j.addCard(Y.clone(),Q[Y.getRarity()]);return j}}class s{data;effect;infinite=!1;scale=1.1;constructor($,J,K=!1,V=1.1){if(this.data=JSON.parse(JSON.stringify($)),!this.data.level)this.data.level=0;this.effect=J,this.infinite=K,this.scale=V}lvl(){return this.data.level}getCost(){return this.data.cost}getData($){return{name:this.getName(),description:this.getDescription(),cost:this.getCost(),locked:this.data.locked||!this.canPayCost($),level:this.data.level}}getName(){return`${this.data.name}${this.infinite&&this.data.level>0?` Lvl. ${this.data.level}`:""}`}getDescription(){let $=this.data.description;$=$.replace("{level}",this.level+"");let J=$.match(/{[^}]*}/g);if(J)for(let K of J){let V=K.substring(1,K.length-1);$=$.replace(K,(0, eval)(V))}return $}canPayCost($){let J=$.owner.getResources();for(let K of this.data.cost){if(K.resource=="turns")continue;if(!J[K.resource])return!1;if(J[K.resource]<K.amt)return!1}return!0}payCost($){let J=$.owner.getResources();for(let K of this.data.cost)if(K.resource==="turns"){$.owner.addTurns(K.amt);continue}else $.owner.setProp(`res_${K.resource}`,J[K.resource]-K.amt,$)}locked(){return this.data.locked}unlock($){if(!this.data.locked)if(this.payCost($),this.effect($,this),this.level++,!this.infinite)this.data.locked=!0;else for(let J of this.data.cost)J.amt=Math.ceil(J.amt*this.scale)}}var w;(function(K){K[K["DISCARD_FROM_HAND"]=0]="DISCARD_FROM_HAND";K[K["GIVE_TO_CONTROLLER"]=1]="GIVE_TO_CONTROLLER"})(w||(w={}));class r{structure=[];addCard($,J=0){if(this.getValidTiers($.card).includes(J))return this.slots[J]=$.card,$.card.onSlottable($),!0;else if(this.isValid($.card)){for(let K of this.getValidTiers($.card))if(this.slots[K]===void 0)return this.slots[K]=$.card,$.card.onSlottable($),!0}return!1}}class a extends r{structure;slots=[];name;props;constructor($){super();this.structure=[{name:"Foundation",slots:1},{name:"Pillars",slots:1},{name:"Doctrine",slots:1}],this.slots.fill(void 0,0,this.structure.length)}getValidTiers($){return $.getProp(f.RELIGION)??[]}addCard($,J=0){return super.addCard($,J)}getCards(){return this.slots}getCardsOfTier($){return[this.slots[$]]}getName(){return this.name}setName($){return this.name=$,this}getProp($){return this.props[$]}getProps(){return this.props}isValid($){return $.getProp(f.RELIGION)!==void 0&&$.getProp(f.RELIGION).filter((J)=>{return this.slots[J]===void 0}).length>0}setProp($,J,K){return this.props[$]=K?new _(J).resolve(K):J,this}toState($){return{name:this.name,props:this.props,structure:this.structure,slots:this.slots.map((J)=>{return J.toState($)}),validity:$.owner.cih().map((J)=>{return this.isValid(J)})}}}class h{name;cards=[];skipped=0;props={};events={};turnPlacement=0;turnsRemaining=25;canWin=!1;winReason="cards in hand";handSize=10;bot=!1;host=!1;botProfile=void 0;resolveBeforeTurn=[];slottedAbilities=[];eventList={};constructor($,J){this.name=Math.random().toString(36).substring(7),this.draw(J,$),this.setProp(f.UPGRADE_SHOP,[]),this.setProp(f.RELIGION,new a("Da Faith")),this.addUpgrade(new s({name:"Take a Crap",description:"Take a bathroom break to draw a card.",cost:[{amt:1,resource:"turns"}],locked:!1},(K)=>{K.owner.draw(K.deck,1),K.deck.addCards(R.fromCardList(1,"poop_deck"))},!0,1.5)),this.addEvent("draw",(K)=>{if(!K.card)return;if(!this.eventList[K.card.getName()])this.eventList[K.card.getName()]={drawn:0,played:0,discarded:0,given:0,text:""};K.card.fireEvents("draw",K),this.eventList[K.card.getName()].drawn++,this.eventList[K.card.getName()].text=K.card.getText()}),this.addEvent("play",(K)=>{if(!this.eventList[K.card.getName()])this.eventList[K.card.getName()]={drawn:0,played:0,discarded:0,given:0,text:""};this.eventList[K.card.getName()].played++,this.eventList[K.card.getName()].text=K.card.getText(),K.owner.addTurns(-1)}),this.addEvent("discard",(K)=>{if(!K.card)return;if(!this.eventList[K.card.getName()])this.eventList[K.card.getName()]={drawn:0,played:0,discarded:0,given:0,text:""};this.eventList[K.card.getName()].discarded++,this.eventList[K.card.getName()].text=K.card.getText()}),this.addEvent("give",(K)=>{if(!this.eventList[K.card.getName()])this.eventList[K.card.getName()]={drawn:0,played:0,discarded:0,given:0,text:""};this.eventList[K.card.getName()].given++,this.eventList[K.card.getName()].text=K.card.getText()}),this.addEvent("res_life_change",(K)=>{if(this.getProp("res_life")<=0){if(!K.deck)return;if(!K.deck.props.added_zombie_deck)K.deck.addCards(R.fromCardList(45,"zombie_deck")),K.deck.shuffle(),K.deck.props.added_zombie_deck=!0}})}addSlottedAbility($){return this.slottedAbilities.push($),this}removeSlottedAbility($){return this.slottedAbilities.splice(this.slottedAbilities.indexOf($),1),this}addResource($,J){if($.startsWith("res_"))$=$.substring(4);if(!this.getProp(`res_${$}`))this.setProp(`res_${$}`,0);this.setProp(`res_${$}`,this.getProp(`res_${$}`)+J)}upgrades(){return this.props[f.UPGRADE_SHOP]||[]}religion(){return this.props[f.RELIGION]||void 0}addUpgrade($){if(!this.props[f.UPGRADE_SHOP])this.props[f.UPGRADE_SHOP]=[];this.props[f.UPGRADE_SHOP].push($),this.fireEvents("new_upgrade",{owner:this,opps:[],deck:void 0,card:void 0})}setHost($=!0){return this.host=$,this}isHost(){return this.host}getResources(){let $={};for(let J in this.props)if(J.startsWith("res_"))$[J.substring(4)]=this.props[J];return $.turns=Infinity,$}getUIs(){return{upgrade:!0,religion:this.props.religion||!1}}getRelevantProps(){let $={};for(let J in this.props)if(!J.startsWith("meta_"))$[J]=this.props[J];return $}getPrivate($=!1){return{name:this.name,cards:this.cards.length,handsize:this.handSize,skipped:this.skipped,props:this.getRelevantProps(),turnsRemaining:this.turnsRemaining,canWin:this.canWin,winReason:this.winReason,host:this.host,you:$,order:this.turnPlacement,interrupts:this.resolveBeforeTurn}}getCards($,J){return this.cards.map((K)=>K.toState({owner:this,opps:$,deck:J,card:K}))}setBot(){return this.bot=!0,this.botProfile=new E(Object.keys(T)[Math.floor(Math.random()*Object.keys(T).length)]),this}isBot(){return this.bot}setName($){return this.name=$,this}getCardStats(){return this.eventList}setTurnPlacement($){return this.turnPlacement=$,this}getTurnPlacement(){return this.turnPlacement}getHandsize(){return this.handSize}getBotProfile(){return this.botProfile}addHandsize($){return this.handSize+=$,this}setHandsize($){return this.handSize=$,this}propList(){return this.props}on($,J){return this.addEvent($,J),this}addEvent($,J){if(!this.events[$])this.events[$]=[];this.events[$].push(J)}getWinReason(){return this.winReason}fireEvents($,J){if(this.events[$])for(let K of this.events[$])K(J);if(this.events[`temp_${$}`]){for(let K of this.events[`temp_${$}`])K(J);delete this.events[`temp_${$}`]}for(let K of this.slottedAbilities){let V=K.playerEvents();if(V[$])for(let Q of V[$])Q(J)}}addTurns($){if(this.turnsRemaining+=$,this.turnsRemaining<=0)this.setCanWin(!0,"plodded across the finish line");return this}setTurns($){return this.turnsRemaining=$,this}getTurns(){return this.turnsRemaining}rollDice(){if(this.getProp("dice")){let $=this.getProp("dice");return $[Math.floor(Math.random()*$.length)]}return-1}setCanWin($,J="cards in hand"){if(this.canWin=$,this.winReason=J,this.canWin)this.fireEvents("can_win",{owner:this,opps:[],card:void 0,deck:void 0});return this}winCheck(){return this.canWin}setProp($,J,K){if(this.props[$]=J,K)this.fireEvents(`${$}_change`,K);return this}getProps(){return this.props}getProp($){return this.props[$]||0}skip(){this.skipped++}skipCheck(){if(this.skipped>0)return this.skipped--,!0;return!1}toPlayerState(){return{name:this.name,cards:this.cards.length,handsize:this.handSize,skipped:this.skipped,props:this.props,turnsRemaining:this.turnsRemaining,canWin:this.canWin,winReason:this.winReason,host:this.host,you:!1,order:this.turnPlacement,interrupts:this.resolveBeforeTurn}}getLogText(){return`\xA7\xA7${this.bot?`<b>[${this.botProfile.getProfileName()}]</b> `:""}${this.host?"<b>[HOST]</b> ":""}${this.name}\xA7player\xA7${JSON.stringify(this.toPlayerState())}\xA7\xA7`}getName(){return this.name}cih(){return this.cards}setCiH($){return this.cards=$,this}inHand(){return this.cards.length}turnStart($){for(let J of this.cards)J.fireEvents("turn_start",{...$,card:J})}draw($,J=1){let K=$.draw(J);for(let V of K){if(!V)continue;if(V.draw(this,[],$),this.fireEvents("draw",{owner:this,opps:[],deck:$,card:V}),J>=1)this.cards=this.cards.concat(V)}}play($,J,K,V){if(this.cards.splice(this.cards.indexOf($),1),!$.doSkipDiscard())K.discardPile.push($.setZone(L.DISCARD));else $.remove({card:$,deck:K,owner:this,opps:J});$.play(this,J,K,V),this.fireEvents("play",{owner:this,opps:J,deck:K,card:$})}give($,J){$.give(this,[J],void 0),this.fireEvents("give",{owner:this,opps:[],deck:void 0,card:$}),J.cards.push($),this.cards.splice(this.cards.indexOf($),1)}discard($,J){$.discard(this,[],J),this.fireEvents("discard",{owner:this,opps:[],deck:J,card:$}),J.discardPile.push($.setZone(L.DISCARD)),this.cards.splice(this.cards.indexOf($),1)}discardRandom($){let J=this.cih()[Math.floor(Math.random()*this.cih().length)];if(J)this.discard(J,$.deck)}discardHand($){while(this.cih().length>0)this.discardRandom($)}giveChoose($){if(this.isBot())this.give(this.weightedGive($),$.opps[0]);else this.resolveBeforeTurn.push(w.GIVE_TO_CONTROLLER)}discardChoose($){if(this.isBot()){let J=this.weightedDiscard($);if(J)this.discard(J,$.deck);else this.discardRandom($)}else this.resolveBeforeTurn.push(w.DISCARD_FROM_HAND)}hasInterrupts(){return this.resolveBeforeTurn.length>0}getInterrupts(){return this.resolveBeforeTurn}clearInterrupts(){return this.resolveBeforeTurn=[],this}randomCard(){return this.cards[Math.floor(Math.random()*this.cards.length)]}weightedDiscard($){let J=Infinity,K=null;for(let V of this.cards)if(V&&this.isBot()){let Q=this.botProfile.evaluate(V,$);if(Q<J*(0.8+Math.random()*0.4))J=Q,K=V}return K}weightedDiscardToHand($){if(this.cih().length>this.getHandsize())while(this.cih().length>this.getHandsize()){let J=this.weightedDiscard($);if(J||!$.deck)this.discard(J,$.deck);else return}}weightedGive($){let J=Infinity,K=null;for(let V of this.cards)if(V&&this.isBot()){let Q=this.botProfile.evaluate(V,$);if(Q<J*(0.8+Math.random()*0.4))J=Q,K=V}return K}weightedPlay($){let J=(-Infinity),K=null;for(let V of this.cards)if(V&&this.botProfile){let Q=this.botProfile.evaluate(V,$);if(Q>J*(0.8+Math.random()*0.4)&&V.canBePlayed($))J=Q,K=V}else console.log("not a bot");return K}getEvent($){return this.events[$]}removeEvent($){return delete this.events[$],this}selectChoices($,J){return[]}evaluate($,J){return 0}}var H;(function(F){F[F["CONNECTED"]=0]="CONNECTED";F[F["DISCONNECTED"]=1]="DISCONNECTED";F[F["SET_NAME"]=2]="SET_NAME";F[F["UPDATE_PLAYER_STATE"]=3]="UPDATE_PLAYER_STATE";F[F["SERVER_MSG"]=4]="SERVER_MSG";F[F["ADD_BOT"]=5]="ADD_BOT";F[F["KICK_PLAYER"]=6]="KICK_PLAYER";F[F["TRANSFER_UPGRADE_SHOP"]=7]="TRANSFER_UPGRADE_SHOP";F[F["BUY_UPGRADE"]=8]="BUY_UPGRADE";F[F["TRANSFER_MARKETPLACE"]=9]="TRANSFER_MARKETPLACE";F[F["TRANSFER_RELIGION"]=10]="TRANSFER_RELIGION";F[F["ADD_RELIGIOUS_TENANT"]=11]="ADD_RELIGIOUS_TENANT";F[F["CREATE_RELIGION"]=12]="CREATE_RELIGION";F[F["DRAW_CARD"]=13]="DRAW_CARD";F[F["PLAY_CARD"]=14]="PLAY_CARD";F[F["GIVE_CARD"]=15]="GIVE_CARD";F[F["DISCARD_TO_HAND"]=16]="DISCARD_TO_HAND";F[F["GET_CHOICES"]=17]="GET_CHOICES";F[F["CHOICE_LIST"]=18]="CHOICE_LIST";F[F["PLAY_PHASE_CONFIRM"]=19]="PLAY_PHASE_CONFIRM";F[F["SEND_INTERRUPTS"]=20]="SEND_INTERRUPTS";F[F["RESOLVE_INTERRUPT"]=21]="RESOLVE_INTERRUPT";F[F["ERROR"]=22]="ERROR"})(H||(H={}));import{WebSocketServer as Y0} from"ws";function K0($=100,J=!0){let K=[],V={},Q=0,X=100;for(let j=X;j>0;j--){let Y=R.fromCardList(300,"basic"),U=[];for(let z=0;z<3+X%3;z++)U.push(new h(7,Y).setBot());for(let z of Object.values(u))K.push(...z.map((B)=>B.clone()));for(let z of K)for(let B=0;B<U.length;B++){let k={owner:U[B],opps:U.filter((Z,e)=>e!==B),card:z},p=z.getTraits(k).profile;for(let Z in p){if(!V[Z])V[Z]=0;V[Z]+=p[Z]}Q++}if(J)console.log(`${j} simulation${j>1?"s":""} remaining... (${Q} iterations)`)}for(let j in V)V[j]/=Q,V[j]=1/V[j];if(J)console.log(V);return V}class b{players={};sockets={};deck;turnPhase=0;activeTurn="";logEntries=[];sendableLogs=[];serverObj=void 0;serverPort=15912;serverConfig={startingHand:4,maxPlayers:6,minPlayers:1,fairness:!0};booted=!1;constructor(){this.deck=R.fromCardList(60,"basic"),this.deck.shuffle()}reset(){if(this.serverObj)this.serverObj.close();this.deck=R.fromCardList(60,"basic"),this.deck.shuffle(),this.sockets={},this.players={},this.turnPhase=0,this.activeTurn="",this.sendableLogs=[],this.log("Server reset!"),this.init(this.serverPort)}static createName(){return[["Cheddar","Swiss","Sewer","Moist","Crusty","Crunchy","Crispy","Bam","Bang","Slam","Meow","Bark","Grand","Del","Dip","Rich","Povert","Rogue","Joleto","Tad","Italian","Spicy","Salty","Sweet","Sour","Bitter","Stinky","Irritating","Meaty","Cool","Neato","Awesome","Sassy"],["amole","lotion","bacon","slice","sliver","fluid","ian","jess","tad","Loaf","Crust","Crunch","Crisp","Ioli","Head","Ino","Pants","Zilla","Shirt","Shoes","Hat","Glove","Sock","Spaghetti","Oritto","Ravioli","Gnocchi","Chilada","Pierogi","Burrito","Taco","Enchilada","Tamale","Changa","Dilla","Nachos","Tilla","Chip","Salsa","Guacamole","Asaurus","Eratops"],[" Mc"," "," "," "," "," "," "," "," Mac"," O'"],["Pan","Tad","Crap","Gene","Friendly","Spicy","Hate","Spinach","Slam","Magic","Eraser","Bougie","Ball","Supremo","Bean","Burger","Bread","Biscuit","Bacon","Bun","Biscuit","Burger","Bread","Kitty","Wood","Morning","Soft","Hard","Raging","",""],["Plumbing","Orama","Adic","Tastic","Full","Loaf","Fruit","Table","Chair","Brian","Brain","Atomy","Acist","Ologist","Doofus","Dorkus","Itis","Person","Biden","Trump","Obama","Bush","Clinton","Reagan","Carter","Folk","Ford","Sandal","Muncher","Potato","Whiskey","Bourbon"]].map((J,K)=>{let V=J[Math.floor(Math.random()*J.length)];if(K>0&&!V.startsWith(" "))V=V.toLowerCase();return V}).join("").split(" ").map((J)=>J[0].toUpperCase()+J.substring(1).toLowerCase()).join(" ")}log($){console.log($),this.logEntries.push($.toString())}gameLog($){this.sendableLogs.push($)}getDeck(){return this.deck}addPlayer(){if(this.serverConfig.fairness)Object.values(this.players).forEach((J)=>J.addTurns(1));let $=Math.random().toString(36).substring(7);if(this.players[$]=new h(this.serverConfig.startingHand,this.deck).setTurnPlacement(Object.keys(this.players).length),this.players[$].addEvent("new_upgrade",(J)=>{this.updateUpgradeShop($)}),this.activeTurn==="")this.activeTurn=$,this.players[$].setHost();return{id:$,index:Object.keys(this.players).length-1}}addBot(){if(this.serverConfig.fairness)Object.values(this.players).forEach((J)=>J.addTurns(1));let $=Math.random().toString(36).substring(7);return this.players[$]=new h(this.serverConfig.startingHand,this.deck).setTurnPlacement(Object.keys(this.players).length).setName(b.createName()).setBot(),this.gameLog(`${this.players[$].getLogText()} joined the game as a bot.`),$}incrementPhase(){let $=!0;for(let X of Object.keys(this.players))if(this.players[X].hasInterrupts()&&!this.players[X].isBot())this.sockets[X].send(JSON.stringify({type:H.SEND_INTERRUPTS,interrupts:this.players[X].getInterrupts()})),$=!1;if(!$)return this.updateAllStates(),!1;let J={owner:this.getActive(),opps:Object.values(this.players).filter((X)=>X!==this.getActive()),deck:this.deck},K=Object.keys(this.players).length>=2&&this.getActive().cih().length>=2&&this.getActive().cih().some((X)=>X.canBeGiven(this.getActive(),{...J,card:X})),V=this.getActive().cih().some((X)=>X.canBePlayed({owner:this.getActive(),opps:Object.values(this.players).filter((j)=>j!==this.getActive()),deck:this.deck,card:X}))||this.getActive().getProp("meta_upgrade").some((X)=>{return X.getData(J)}),Q=this.getActive().cih().length>this.getActive().getHandsize();if(this.turnPhase===0)if(K)this.turnPhase=1;else if(V)this.turnPhase=2;else if(Q)this.turnPhase=3;else this.incrementTurn();else if(this.turnPhase===1)if(V)this.turnPhase=2;else if(Q)this.turnPhase=3;else this.incrementTurn();else if(this.turnPhase===2)if(Q)this.turnPhase=3;else this.incrementTurn();this.updateAllStates()}incrementTurn(){if(this.gameLog(`${this.getActive().getLogText()} ended their turn.`),this.gameLog("===NEW TURN==="),this.turnPhase=0,Object.values(this.players).length==0)this.activeTurn="",this.updateAllStates();else if(this.activeTurn=Object.keys(this.players)[(Object.keys(this.players).indexOf(this.activeTurn)+1)%Object.keys(this.players).length],this.gameLog(`${this.getActive().getLogText()} begins their turn.`),this.updateAllStates(),this.getActive().skipCheck())this.gameLog(`${this.getActive().getLogText()} is skipped.`),this.incrementTurn();else if(this.getActive().isBot())this.playBotTurn()}playBotTurn(){let $=Object.keys(this.players).filter((Q)=>Q!==this.activeTurn).map((Q)=>this.players[Q]),J={owner:this.getActive(),opps:$,deck:this.deck};this.getActive().draw(this.deck,1),this.gameLog(`${this.getActive().getLogText()} draws a card.`);let K=null;try{K=this.getActive().cih().filter((Q)=>Q.canBePlayed({...J,card:Q}))}catch(Q){this.gameLog(`${this.getActive().getLogText()} has an error in their hand: ${Q}`)}if(this.turnPhase=1,this.updateAllStates(),this.getActive().cih().length>=2){let Q=this.getActive().weightedGive(J);if(Q){let X=$[Math.floor(Math.random()*$.length)];this.gameLog(`${this.getActive().getLogText()} gives ${Q.getLogText()} to ${X.getLogText()}.`),this.getActive().give(Q,X)}}else this.gameLog(`${this.getActive().getLogText()} doesn't have enough cards to be generous.`);let V=K.length>0;if(V)this.turnPhase=2;else this.turnPhase=3;if(this.updateAllStates(),V){let Q=this.getActive().weightedPlay(J);if(Q)this.gameLog(`${this.getActive().getLogText()} plays ${Q.getLogText()}.`),this.getActive().play(Q,$,this.deck);this.turnPhase=3,this.updateAllStates()}this.getActive().weightedDiscardToHand(J),this.incrementTurn()}updateReligion($){if(this.players[$].religion())this.sockets[$].send(JSON.stringify({type:H.TRANSFER_RELIGION,religion:this.players[$].religion().toState({owner:this.players[$],opps:[],deck:this.deck})}))}updateUpgradeShop($){this.sockets[$].send(JSON.stringify({type:H.TRANSFER_UPGRADE_SHOP,shop:this.players[$].getProp("meta_upgrade").map((K)=>{return K.getData({owner:this.players[$],opps:[],deck:this.deck})})}))}disconnect($,J=""){for(let K of this.players[$].cih())this.deck.discardPile.push(K);if($===this.activeTurn)this.incrementTurn();if(this.log(`Player ${$} disconnected (${this.players[$].getLogText()}) - ${J}`),this.gameLog(`${this.players[$]} disconnected.`),this.sockets[$])this.sockets[$].send(JSON.stringify({type:H.SERVER_MSG,message:J})),this.sockets[$].send(JSON.stringify({type:H.DISCONNECTED}));if(delete this.players[$],delete this.sockets[$],this.serverConfig.fairness)Object.values(this.players).forEach((K)=>K.addTurns(-1));if(Object.keys(this.players).length>0){let K=Object.keys(this.players).find((V)=>!this.players[V].isBot());if(K)this.players[K].setHost(),this.gameLog(`${this.players[K]} is now the host.`);else this.log("No non-bots left, server entering reset mode"),this.reset()}if(Object.keys(this.players).length===0)this.activeTurn="",this.log("No non-bots left, server entering reset mode"),this.reset();this.updateAllStates()}getActive(){if(this.activeTurn==="")throw new Error("No active turn");return this.players[this.activeTurn]}sendState($){let J=Object.keys(this.players).filter((Q)=>Q!==$).map((Q)=>this.players[Q]),K=Object.keys(this.players).indexOf(this.activeTurn),V=Object.keys(this.players).indexOf($);if(this.players[$].isBot())return;this.sockets[$].send(JSON.stringify({type:H.UPDATE_PLAYER_STATE,state:{game:{players:Object.values(this.players).map((Q,X)=>Q.getPrivate(X===V)),turnPhase:this.turnPhase,uis:this.players[$].getUIs(),activeTurn:K,deck:this.deck.length,config:this.serverConfig,logs:this.sendableLogs.map((Q)=>Q.toString()),discard:this.deck.discardPile.map((Q)=>({name:Q.getDisplayName(),text:Q.getFormulatedText({owner:this.players[$],opps:J,deck:this.deck,card:Q}),rarity:Q.getRarity(),props:Q.getProps()}))},personal:this.players[$].getCards(J,this.deck)}}))}updateAllStates(){Object.keys(this.players).forEach(($)=>this.sendState($))}adjustAIHeuristics($=250){console.log("Adjusting AI heuristics...");let J=K0($,!1);for(let K of Object.keys(T)){console.log(`\n=== ${K} ===`);for(let V of Object.keys(J))if(T[K][V]){let Q=Math.round(T[K][V]*J[V]*100)/100;console.log(`${V}: ${T[K][V]} -> ${Q}`),T[K][V]=Q}}}init($=15912){let J=this;if(J.log(`Server initialized on port ${$}`),this.serverPort=$,!this.booted)this.adjustAIHeuristics();this.booted=!0,this.serverObj=new Y0({port:$}),this.serverObj.on("connection",function K(V){V.on("message",function X(j){let Y=JSON.parse(j),U=Y.id,z=Object.keys(J.players).filter((B)=>B!==U).map((B)=>J.players[B]);switch(Y.type){case H.SET_NAME:if(Y.name.length<1)Y.name=b.createName();J.players[U].setName(Y.name),J.gameLog(`${J.players[U].getLogText()} joined the game`),J.updateAllStates();break;case H.DRAW_CARD:if(J.activeTurn==U&&J.turnPhase==0)J.players[U].draw(J.deck,1),J.gameLog(`${J.players[U].getLogText()} drew a card.`),J.incrementPhase();else if(J.activeTurn!==U)V.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not your turn."}));else V.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not the draw phase."}));J.updateAllStates();break;case H.GIVE_CARD:let B=Y.idInHand,k=Object.keys(J.players)[Y.target];if(J.activeTurn==U&&J.turnPhase==1&&k!==U&&J.players[U].cih().length>=2&&J.players[U].cih()[B].canBeGiven(J.players[k],{card:J.players[U].cih()[B],owner:J.players[U],opps:z,deck:J.deck}))J.gameLog(`${J.players[U].getLogText()} gives ${J.players[U].cih()[B].getLogText()} to ${J.players[k].getLogText()}.`),J.players[U].give(J.players[U].cih()[B],J.players[k]),J.incrementPhase();else if(J.activeTurn===U)V.send(JSON.stringify({type:H.ERROR,message:"This card can't be gifted - not your turn."}));else if(J.turnPhase!==1)V.send(JSON.stringify({type:H.ERROR,message:"This card can't be gifted - not the give phase."}));else if(J.players[U].cih().length<2)J.gameLog(`${J.players[U].getLogText()} doesn't have enough cards to be generous.`),J.incrementPhase();else V.send(JSON.stringify({type:H.ERROR,message:"This card can't be gifted - not giveable to this player."}));break;case H.GET_CHOICES:let p=Y.idInHand,Z=J.players[U].cih()[p];if(Z.canBePlayed({owner:J.players[U],opps:z,deck:J.deck,card:Z})&&J.activeTurn===U&&J.turnPhase==2){let D=JSON.stringify({type:H.CHOICE_LIST,card:p,splits:Z.getAbilities().map((q)=>q.getChoices().length),choices:Z.getChoices({owner:J.players[U],opps:z,deck:J.deck,card:Z})});V.send(D)}else if(J.activeTurn===U)V.send(JSON.stringify({type:H.ERROR,message:"This card can't have choices selected - not your turn."}));else if(J.turnPhase!==2)V.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not the play phase."}));else V.send(JSON.stringify({type:H.ERROR,message:"This card can't be played"}));break;case H.PLAY_CARD:let e=Y.idInHand,x=J.players[U].cih()[e],$0=Y.choices,O=$0.map((D,q)=>{let N=x.orderAbilities()[q];return D.map((l,V0)=>{switch(N.informChoices({owner:J.players[U],opps:z,deck:J.deck,card:x})[V0].choice){case S.OPPONENT:case S.PLAYER:return J.players[Object.keys(J.players)[l]];case S.CARD_IN_HAND:return J.players[U].cih()[l];case S.CARD_IN_DISCARD:return J.deck.discardPile[l]}})});if(J.activeTurn===U&&J.turnPhase==2&&x.canBePlayed({owner:J.players[U],opps:z,deck:J.deck,card:x})){let D={owner:J.players[U],opps:z,deck:J.deck,card:x};if(x.getChoices(D).length>0)J.gameLog(`${J.players[U].getLogText()} plays ${x.getLogText()} with the following choices:\n${$0.map((q,N)=>`${x.orderAbilities()[N].getFormulatedText(D)}: ${O[N].map((l)=>l.getLogText()).join(", ")}`).join("\n")}`);else J.gameLog(`${J.players[U].getLogText()} plays ${x.getLogText()}.`);J.players[U].play(x,z,J.deck,O),J.incrementPhase()}else if(J.activeTurn===U)V.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not your turn."}));else if(J.turnPhase!==2)V.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not the play phase."}));else V.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not playable."}));break;case H.DISCARD_TO_HAND:let Q0=Y.idInHand;if(J.activeTurn!==U)V.send(JSON.stringify({type:H.ERROR,message:"This card can't be discarded - not your turn."}));else if(J.turnPhase!==3)V.send(JSON.stringify({type:H.ERROR,message:"This card can't be discarded - not the discard phase."}));else if(J.players[U].cih().length<=J.players[U].getHandsize())V.send(JSON.stringify({type:H.ERROR,message:"This card can't be discarded - you don't have enough cards in hand."})),J.updateAllStates(),J.incrementTurn();else for(let D of Q0)if(J.players[U].cih().length>=D+1){let q=[J.players[U].cih()[D]];J.players[U].setCiH(J.players[U].cih().filter((N)=>!q.includes(N)));for(let N of q)J.deck.discardPile.push(N);if(J.updateAllStates(),J.players[U].cih().length<=J.players[U].getHandsize())break}break;case H.ADD_BOT:if(J.players[U].isHost())J.addBot(),J.updateAllStates();else V.send(JSON.stringify({type:H.ERROR,message:"You can't add a bot - you aren't the host."}));break;case H.KICK_PLAYER:if(J.players[U].isHost()){let D=Y.target,q=Object.keys(J.players)[D];if(q===U)V.send(JSON.stringify({type:H.ERROR,message:"You can't kick yourself."}));else J.gameLog(`${J.players[U]} kicked ${J.players[q]}.`),J.disconnect(q,Y.message??"The host hated your guts.")}else V.send(JSON.stringify({type:H.ERROR,message:"You can't kick a player - you aren't the host."}));break;case H.TRANSFER_UPGRADE_SHOP:if(J.getActive().getUIs().upgrade)J.updateUpgradeShop(U);else V.send(JSON.stringify({type:H.ERROR,message:"You haven't unlocked the upgrade shop."}));break;case H.TRANSFER_RELIGION:if(J.players[U].getUIs().religion)J.updateReligion(U);else V.send(JSON.stringify({type:H.ERROR,message:"You haven't unlocked religion yet."}));break;case H.ADD_RELIGIOUS_TENANT:let A=Y.idInHand;if(J.players[U].cih().length<A+1||!J.players[U].cih()[A])V.send(JSON.stringify({type:H.ERROR,message:"You can't add this tenant - invalid tenant."}));else if(!J.players[U].getUIs().religion)V.send(JSON.stringify({type:H.ERROR,message:"You haven't unlocked religion yet."}));else if(!J.players[U].religion())V.send(JSON.stringify({type:H.ERROR,message:"You don't have a religion."}));else if(J.players[U].religion().isValid(J.players[U].cih()[A]))J.players[U].religion().addCard({owner:J.players[U],opps:z,deck:J.deck,card:J.players[U].cih()[A].clone()}),J.players[U].setCiH(J.players[U].cih().filter((D)=>D!==J.players[U].cih()[A])),J.updateReligion(U),J.incrementPhase();break;case H.RESOLVE_INTERRUPT:let J0=J.players[U].getInterrupts(),y=Y.interrupts;if(y.length!==J0.length)V.send(JSON.stringify({type:H.ERROR,message:"You can't resolve these interrupts - invalid number of interrupts."}));else{let D=[],q=[];for(let N=0;N<y.length;N++)switch(J0[N]){case w.DISCARD_FROM_HAND:if(J.players[U].cih().length>0)D.push(J.players[U].cih()[y[N]]);break;case w.GIVE_TO_CONTROLLER:if(J.players[U].cih().length>0&&J.players[U].cih()[y[N]])q.push(J.players[U].cih()[y[N]]);break}D.forEach((N)=>{J.players[U].discard(N,J.deck)}),q.forEach((N)=>{J.players[U].give(N,J.getActive())}),J.players[U].clearInterrupts()}J.incrementPhase();break;case H.BUY_UPGRADE:let v=Y.upgrade,F=J.getActive().getProp("meta_upgrade");if(J.activeTurn!==U)V.send(JSON.stringify({type:H.ERROR,message:"You can't buy an upgrade - not your turn."}));else if(!J.getActive().getUIs().upgrade)V.send(JSON.stringify({type:H.ERROR,message:"You can't buy an upgrade - you haven't unlocked the upgrade shop."}));else if(J.turnPhase!==2)V.send(JSON.stringify({type:H.ERROR,message:"You can't buy an upgrade - not the play phase."}));else if(F.length<=v||v<0||F[v].locked()||!F[v].canPayCost({owner:J.getActive(),opps:z,deck:J.deck}))V.send(JSON.stringify({type:H.ERROR,message:"You can't buy an upgrade - invalid upgrade."}));else F[v].unlock({owner:J.getActive(),opps:z,deck:J.deck}),J.gameLog(`${J.getActive().getLogText()} bought ${F[v].getData({owner:J.getActive(),opps:z,deck:J.deck}).name}.`),J.incrementPhase(),J.updateAllStates(),J.updateUpgradeShop(U);break}}),V.on("close",function X(j,Y){let U=Object.keys(J.sockets).find((z)=>J.sockets[z]===V);J.disconnect(U)});let Q=J.addPlayer();J.sockets[Q.id]=V,V.send(JSON.stringify({type:H.CONNECTED,connected:Q.id,host:Object.keys(J.players)[0]==Q.id,turn:Q.index}))})}}var F0=new b;F0.init(15912);
