// @bun
var M;(function(F){F[F["DECK"]=0]="DECK";F[F["TOP_DECK"]=1]="TOP_DECK";F[F["BOTTOM_DECK"]=2]="BOTTOM_DECK";F[F["RANDOM_DECK"]=3]="RANDOM_DECK";F[F["HAND"]=4]="HAND";F[F["DISCARD"]=5]="DISCARD";F[F["NONE"]=6]="NONE"})(M||(M={}));var z;(function(X){X[X["PLAYER"]=0]="PLAYER";X[X["OPPONENT"]=1]="OPPONENT";X[X["CARD_IN_HAND"]=2]="CARD_IN_HAND";X[X["CARD_IN_DISCARD"]=3]="CARD_IN_DISCARD";X[X["CARD"]=4]="CARD"})(z||(z={}));var W;(function(L){L[L["SELF"]=0]="SELF";L[L["OPPONENT_MOST_CARDS"]=1]="OPPONENT_MOST_CARDS";L[L["OPPONENT_LEAST_CARDS"]=2]="OPPONENT_LEAST_CARDS";L[L["OPPONENT_RANDOM"]=3]="OPPONENT_RANDOM";L[L["PLAYER_RANDOM"]=4]="PLAYER_RANDOM";L[L["PLAYER_MOST_CARDS"]=5]="PLAYER_MOST_CARDS";L[L["PLAYER_LEAST_CARDS"]=6]="PLAYER_LEAST_CARDS";L[L["CARD_IN_HAND_LEAST_POWER"]=7]="CARD_IN_HAND_LEAST_POWER";L[L["CARD_IN_HAND_MOST_POWER"]=8]="CARD_IN_HAND_MOST_POWER";L[L["CARD_IN_HAND_RANDOM"]=9]="CARD_IN_HAND_RANDOM";L[L["CARD_IN_DISCARD_LEAST_POWER"]=10]="CARD_IN_DISCARD_LEAST_POWER";L[L["CARD_IN_DISCARD_MOST_POWER"]=11]="CARD_IN_DISCARD_MOST_POWER";L[L["CARD_IN_DISCARD_RANDOM"]=12]="CARD_IN_DISCARD_RANDOM";L[L["OPPONENT_MOST_TURNS_REMAINING"]=13]="OPPONENT_MOST_TURNS_REMAINING";L[L["OPPONENT_LEAST_TURNS_REMAINING"]=14]="OPPONENT_LEAST_TURNS_REMAINING";L[L["PLAYER_MOST_TURNS_REMAINING"]=15]="PLAYER_MOST_TURNS_REMAINING";L[L["PLAYER_LEAST_TURNS_REMAINING"]=16]="PLAYER_LEAST_TURNS_REMAINING"})(W||(W={}));var S;(function(F){F[F["BASIC"]=0]="BASIC";F[F["COMMON"]=1]="COMMON";F[F["UNCOMMON"]=2]="UNCOMMON";F[F["RARE"]=3]="RARE";F[F["MYTHIC"]=4]="MYTHIC";F[F["LEGENDARY"]=5]="LEGENDARY";F[F["HAXOR"]=6]="HAXOR"})(S||(S={}));class _{callback;cachedValue;value=!1;constructor($){if(this.callback=$,typeof $!=="function")this.value=!0,this.cachedValue=$}resolve(...$){if(this.value)return this.cachedValue;return this.callback(...$)}getCallback(){return this.callback}}class N{name;abilities=[];power=1;rarity=S.COMMON;canPlay=new _(!0);canGive=new _(!0);discardable=!0;zone=M.NONE;props={};constructor($,V){this.name=$,this.abilities=V}setZone($){return this.zone=$,this}remove($){this.move(M.NONE,$)}move($,V,J){let K=this.zone;switch(K){case M.DECK:V.deck.splice(V.deck.indexOf(this),1);break;case M.HAND:if(J&&J.from)J.from.cih().splice(J.from.cih().indexOf(this),1);else V.owner.cih().splice(V.owner.cih().indexOf(this),1);break;case M.DISCARD:V.deck.discardPile.splice(V.deck.discardPile.indexOf(this),1);break}if(this.fireEvents(`moveFrom_${Object.values(M)[K]}`,V),$!==M.NONE){switch($){case M.DECK:case M.RANDOM_DECK:V.deck.push(this),V.deck.shuffle();break;case M.TOP_DECK:V.deck.unshift(this);break;case M.BOTTOM_DECK:V.deck.push(this);break;case M.DISCARD:V.deck.discardPile.push(this);break;case M.HAND:if(J&&J.to)J.to.cih().push(this);else V.owner.cih().push(this);break}if(this.zone=$,this.zone===M.TOP_DECK||this.zone===M.BOTTOM_DECK||this.zone===M.RANDOM_DECK)this.zone=M.DECK;this.fireEvents(`moveTo_${Object.values(M)[this.zone]}`,V)}else this.zone=$}setCanPlay($){return this.canPlay=new _($),this}setCanGive($){return this.canGive=new _($),this}setProps($){return this.props=$,this}setProp($,V,J){return this.props[$]=V,this}addAbility($){return this.abilities.push($),this}getChoices($){return this.orderAbilities().map((V)=>{return V.informChoices({...$,card:this})}).flat()}skipDiscard(){return this.discardable=!1,this}doSkipDiscard(){return!this.discardable}getProps(){let $={};for(let V of this.orderAbilities())for(let J of Object.keys(V.getProps()))if(!$[J]&&J.startsWith("meta_"))$[J]=V.getProp(J);else if(Array.isArray($[J]))$[J].push(V.getProp(J));return{...this.props,...$}}getProp($){return this.getProps()[$]}clone(){let $=new N(this.name,this.abilities.map((V)=>V.clone()));return $.setPow(this.power),$.setRarity(this.rarity),$.setCanPlay(this.canPlay.getCallback()),$.setCanGive(this.canGive.getCallback()),$.setProps({...this.props}),$}canBePlayed($){if(this.abilities.map((J)=>J.canBePlayed($)).includes(!1))return!1;return this.canPlay.resolve($)}canBeGiven($,V){if(this.abilities.map((K)=>K.canBeGiven($,V)).includes(!1))return!1;return this.canGive.resolve($,V)}setRarity($){return this.rarity=$,this}getRarity(){return this.rarity}getAbilities(){return this.abilities}getDisplayName(){let $="";if(this.pow()!==1){if(this.pow()>1)$=` +${this.pow()-1}`;else if(this.pow()<1)$=` ${this.pow()-1}`}return this.getName()+$}getName(){return this.name}setName($){return this.name=$,this}toState($){let V={...this.getProps()};return delete V.deck,{name:this.getDisplayName(),text:this.getFormulatedText($),rarity:this.getRarity(),power:this.pow(),formula:this.getFormulas(),props:V,playable:this.canBePlayed({owner:$.owner,opps:$.opps,deck:$.deck,card:this})}}toCardState(){let $={...this.getProps()};return delete $.deck,{name:this.name,power:this.power,rarity:this.rarity,text:this.getText(),props:$}}getLogText(){return`\xA7\xA7${this.name}\xA7card\xA7${JSON.stringify(this.toCardState())}\xA7\xA7`}pow(){return Math.min(this.power,999)}setPow($){if(this.power=$,this.power>999)this.power=999;return this}explode($){this.move(M.NONE,$);let V=[];if(this.getProp("fragment"))return V;else{let J=1;for(let K of this.orderAbilities()){let Q=new N(`${this.getName()} Fragment #${J}`,[K.clone()]).setPow(this.pow()).setRarity(this.getRarity()).setProps({...this.props});Q.setProp("fragment",!0),J++,V.push(Q)}return V}}onSlottable($){for(let V of this.orderAbilities())if(V.getProp("slotted_ability"))V.onSlot($)}orderAbilities(){return this.abilities.sort(($,V)=>{if($.constructor.name==="CostAbility"&&V.constructor.name!=="CostAbility")return-1;else if($.constructor.name!=="CostAbility"&&V.constructor.name==="CostAbility")return 1;else if($.constructor.name==="PlayerRestrictionAbility"&&V.constructor.name!=="PlayerRestrictionAbility")return-1;else if($.constructor.name!=="PlayerRestrictionAbility"&&V.constructor.name==="PlayerRestrictionAbility")return 1;else if($.constructor.name==="PlayerRestrictionAbilityNeg"&&V.constructor.name!=="PlayerRestrictionAbilityNeg")return-1;else if($.constructor.name!=="PlayerRestrictionAbilityNeg"&&V.constructor.name==="PlayerRestrictionAbilityNeg")return 1;else if($.constructor.name==="PlayerPredicateRestrictionAbility"&&V.constructor.name!=="PlayerPredicateRestrictionAbility")return-1;else if($.constructor.name!=="PlayerPredicateRestrictionAbility"&&V.constructor.name==="PlayerPredicateRestrictionAbility")return 1;else if($.hasRestriction()&&!V.hasRestriction())return-1;else if(!$.hasRestriction()&&V.hasRestriction())return 1;else if($.getProp("slotted_ability")&&!V.getProp("slotted_ability"))return 1;else if(!$.getProp("slotted_ability")&&V.getProp("slotted_ability"))return-1;return 0})}fireEvents($,V){for(let J of this.orderAbilities())J.fireEvents($,V)}play($,V,J,K){let Q=0;if(this.canBePlayed({owner:$,opps:V,deck:J,card:this}))for(let X of this.orderAbilities()){let O=K?K[Q]:void 0;X.fireEvents("play",{owner:$,opps:V,deck:J,card:this,choices:O}),Q++}}draw($,V,J){for(let K of this.orderAbilities())K.fireEvents("draw",{owner:$,opps:V,deck:J,card:this})}give($,V,J){for(let K of this.orderAbilities())K.fireEvents("give",{owner:$,opps:V,deck:J,card:this})}discard($,V,J){for(let K of this.orderAbilities())K.fireEvents("discard",{owner:$,opps:V,deck:J,card:this})}getText(){return this.orderAbilities().map((V)=>V.getText()).join("\n")}getFormulatedText($){return this.orderAbilities().map((J)=>J.getFormulatedText($)).join("\n")}getFormulas(){return this.orderAbilities().map((V)=>{if(V.hasFormula())return V.getFormula();return""})}getTraits($){let J=this.orderAbilities().map((Q)=>{return Q.ai()}),K={profile:{}};for(let Q of J)for(let X of Object.keys(Q)){let O=new _(Q[X]).resolve($);if(K.profile[X])K.profile[X]+=O;else K.profile[X]=O}return K}static combine(...$){let V=$.map((Q)=>Q.clone()),J=new N(V.map((Q)=>Q.getName()).join(" + "),[...V.map((Q)=>Q.getAbilities()).flat()]);J.setPow(Math.floor(V.map((Q)=>Q.pow()).reduce((Q,X)=>Q+X,0)/V.length)),J.setRarity(Math.floor(V.map((Q)=>Q.getRarity()).reduce((Q,X)=>Q+X,0)/V.length)),J.setCanPlay((Q)=>{for(let X of V)if(!X.canBePlayed(Q))return!1;return!0});let K={};for(let Q of V)K={...K,...Q.getProps()};return J.setProps(K),J}}var O0={Jesse:{collectResource:10,spendResource:-15,affectsSelf:5,affectsOpponents:20,changesGame:5,meme:10,oppWinSetback:50,discardOpponentCards:10},Ian:{collectResource:20,spendResource:10,drawsCards:10,changesGame:10,affectsSelf:15,discardsCards:-10,unlockUpgrades:10}},T=O0;class w{optimality=1;profile={};profileName="";constructor($=""){if(T[$])this.profileName=$;else this.profileName=Object.keys(T)[Math.floor(Math.random()*Object.keys(T).length)];this.profile=T[this.profileName]}getProfileName(){return this.profileName}getProfile(){return this.profile}static makeSpecificChoice($,V){let J=[];if(V.pointer instanceof Function)J.push(V.pointer($));else switch(V.pointer){case W.SELF:J.push($.owner);break;case W.OPPONENT_MOST_CARDS:J.push(...$.opps.sort((Q,X)=>X.inHand()-Q.inHand()));break;case W.OPPONENT_LEAST_CARDS:J.push(...$.opps.sort((Q,X)=>Q.inHand()-X.inHand()));break;case W.OPPONENT_RANDOM:let K=$.opps.sort(()=>Math.random()-0.5);J.push(...K);break;case W.CARD_IN_DISCARD_LEAST_POWER:J.push(...$.deck.discardPile.sort((Q,X)=>{if(!Q||!X)return 0;return Q.pow()-X.pow()}));break;case W.CARD_IN_DISCARD_MOST_POWER:J.push(...$.deck.discardPile.sort((Q,X)=>{if(!Q||!X)return 0;return X.pow()-Q.pow()}));break;case W.CARD_IN_DISCARD_RANDOM:J.push(...$.owner.cih().sort(()=>Math.random()-0.5));break;case W.CARD_IN_HAND_LEAST_POWER:J.push(...$.owner.cih().sort((Q,X)=>{if(!Q||!X)return 0;return Q.pow()-X.pow()}));break;case W.CARD_IN_HAND_MOST_POWER:J.push(...$.owner.cih().sort((Q,X)=>{if(!Q||!X)return 0;return X.pow()-Q.pow()}));break;case W.CARD_IN_HAND_RANDOM:J.push(...$.owner.cih().sort(()=>Math.random()-0.5));break;case W.PLAYER_RANDOM:J.push(...[$.owner,...$.opps].sort(()=>Math.random()-0.5));break;case W.PLAYER_MOST_CARDS:J.push(...[$.owner,...$.opps].sort((Q,X)=>X.inHand()-Q.inHand()));break;case W.PLAYER_LEAST_CARDS:J.push(...[$.owner,...$.opps].sort((Q,X)=>Q.inHand()-X.inHand()));break;case W.PLAYER_MOST_TURNS_REMAINING:J.push(...[$.owner,...$.opps].sort((Q,X)=>X.getTurns()-Q.getTurns()));break;case W.PLAYER_LEAST_TURNS_REMAINING:J.push(...[$.owner,...$.opps].sort((Q,X)=>Q.getTurns()-X.getTurns()));break;case W.OPPONENT_MOST_TURNS_REMAINING:J.push(...$.opps.sort((Q,X)=>X.getTurns()-Q.getTurns()));break;case W.OPPONENT_LEAST_TURNS_REMAINING:J.push(...$.opps.sort((Q,X)=>Q.getTurns()-X.getTurns()));break}return J}optimalityCrux($){let V=this.optimality,J=$.length,K=(X)=>{let O=2*J,F=-(1-V)*X;return O*(1-1/(1+Math.E**F))},Q=Math.random()*100;return $[Math.floor(K(Q))]}selectChoices($,V){if(!V.card)return[];else{let J=V.card.getChoices(V),K=[];for(let Q of J)K.push(this.optimalityCrux(w.makeSpecificChoice(V,Q)))}}evaluate($,V){let J=$.getTraits({...V,card:$}),K=0;for(let Q in J.profile)if(this.profile[Q])try{K+=J.profile[Q]*this.profile[Q]}catch{console.log(`Error evaluating card ${$.getName()} with weight ${Q}`)}return K}}class j{text;callback;choices=new _([]);formula="{pow}";canPlay=new _(!0);canGive=new _(!0);props={};events={};traits={};constructor($,V,J){this.text=$,this.callback=J,this.choices=new _(V),this.addEvent("play",(K)=>{this.exec(K)})}ai(){return this.traits}sai($,V){return this.traits={...$},this}isCostAbility(){return this.props.cost_ability??!1}clone(){let $=new j(this.text,this.choices.resolve(),this.callback);$.setFormula(this.formula),$.setCanPlay(this.canPlay.getCallback()),$.setCanGive(this.canGive.getCallback()),$.sai(this.ai());for(let V of Object.keys(this.props))$.setProp(V,this.props[V]);return $}getChoices(){return this.choices.resolve()}getCallback(){return this.callback}setCanPlay($){return this.canPlay=new _($),this}setCanGive($){this.canGive=new _($)}canBePlayed($){let V=this.choices.resolve($);if(V.length>0){for(let J of V)if(J.choice===z.OPPONENT){if($.opps.length===0)return!1}else if(J.choice===z.CARD_IN_DISCARD){if(!$.deck)return!1;if($.deck.discardPile.length===0)return!1}else if(J.choice===z.CARD_IN_HAND){if($.owner.cih().length<=1)return!1}}return this.canPlay.resolve($)}canBeGiven($,V){return this.canGive.resolve($,V)}setText($){return this.text=$,this}hasRestriction(){return typeof this.canPlay==="function"||!this.canPlay}getRawText(){return this.text}getText(){return this.text.replace("{formula}",this.textualizeFormula())}getFormulatedText($){return this.text.replace("{formula}",this.calcFormula($))}informChoices($){return this.choices.resolve($)}setFormula($){return this.formula=$,this}textualizeFormula(){let $=this.formula;for(let V in this.props)$=$.replace(`{${V}}`,this.props[V]);return $}calcFormula($){let V=this.textualizeFormula();try{V=V.replace("{pow}",$.card.pow().toString())}catch{V=V.replace("{pow}","1")}return(0, eval)(V)}makeChoices($){let V=[];for(let J of this.informChoices($)){let K=w.makeSpecificChoice($,J),Q=0;if((J.restriction??((O)=>!0))($)||V.indexOf(K[Q])!==-1&&J.distinct)while(V.indexOf(K[Q])!==-1&&Q<K.length-1)Q++;if(Q>=K.length)V.push(null);V.push(K[Q])}return V}exec($){this.callback($,$.choices??this.makeChoices($))}on($,V){return this.addEvent($,V),this}addEvent($,V){if(!this.events[$])this.events[$]=[];this.events[$].push(V)}removeEvent($){if(this.events[$])delete this.events[$];return this}getEvent($){return this.events[$]}hasFormula(){return this.text.indexOf("{formula}")!==-1}getFormula(){return this.formula}fireEvents($,V){if(this.events[$])for(let J of this.events[$])J(V);if(this.events[`temp_${$}`]){for(let J of this.events[`temp_${$}`])J(V);delete this.events[`temp_${$}`]}}getProps(){return this.props}getProp($){return this.props[$]}setProp($,V){return this.props[$]=V,this}}class t extends j{constructor($){super("Increase the power of a card in your hand by {formula}",[{choice:z.CARD_IN_HAND,pointer:W.CARD_IN_HAND_LEAST_POWER}],(V,J)=>{if(V.choices)V.choices[0].setPow(V.choices[0].pow()+this.calcFormula(V))});this.sai({improvesCard:(V)=>{return(V?V.pow?V.pow():1:1)+$}}),this.setFormula(`{pow} + ${$}`)}}class d extends j{constructor($){super("Discard {formula} cards at random",[],(V,J)=>{for(let K=0;K<this.calcFormula(V);K++)V.owner.discardRandom(V)});this.sai({affectsSelf:(V)=>V.card.pow()+$,discardsCards:(V)=>V.card.pow()+$}),this.setFormula(`${$} - {pow}`)}}class c extends j{constructor(){super("Remove all other copies of this card from the game",[],($,V)=>{let J=$.opps.concat($.owner),K=[];for(let Q of J)K.push(...Q.cih().filter((X)=>{if(!X||!$.card)return!1;return X.getName()===$.card.getName()}));K.push(...$.deck.discardPile.filter((Q)=>{if(!Q||!$.card)return!1;return Q.getName()===$.card.getName()})),K.push(...$.deck.filter((Q)=>{if(!Q||!$.card)return!1;return Q.getName()===$.card.getName()})),K.forEach((Q)=>{Q.remove($)}),$.card.skipDiscard(),$.deck.shuffle()});this.sai({changesGame:1})}}class i extends j{constructor(){super("Explode a card in your hand. The new cards each have power {formula}.",[{choice:z.CARD_IN_HAND,distinct:!0,pointer:W.CARD_IN_HAND_MOST_POWER,restriction:($)=>{return!$.card.getProp("fragment")}}],($,V)=>{V[0].explode($).forEach((Q)=>{Q.setPow(this.calcFormula($)),Q.move(M.HAND,$)})});this.sai({drawsCards:($)=>{return this.calcFormula($)},improvesCard:($)=>this.calcFormula($)})}}class v extends j{constructor($,V){super(`Add {formula} ${V}`,[],(J)=>{let K=this.calcFormula(J),Q=J.owner.getProp(`res_${V}`)??0;J.owner.setProp(`res_${V}`,Q+K,J)});if(this.setProp("resource",!0),!this.getProp("produce"))this.setProp("produce",[]);this.setProp("produce",[...this.getProp("produce"),V]),this.setFormula(`{pow} + ${$} - 1`),this.sai({collectResource:$})}}class m extends j{constructor($,V=75,J=!0,K=!1){super(`Add the ${$.replace("_"," ").replace(" deck","")} deck to the game${J?" if it hasn't been already":""}`,[],(Q)=>{if(C[$]&&(!J||!Q.deck.props[`added_${$}`]))Q.deck.addCards(q.fromCardList(V,$)),Q.deck.shuffle()});if(J&&K)this.setCanPlay((Q)=>{return!Q.deck.props[`added_${$}`]});this.sai({addCardsToDeck:V,changesGame:1}),this.setProp("deck",!0)}}class x extends j{constructor(){super("Play only if you have 0 or less life",[],($)=>{});this.setCanPlay(($)=>{return $.owner.getProp("res_life")&&$.owner.getProp("res_life")<=0}),this.sai({},{pbp:["res_life"]})}}class s extends j{constructor($){super(`${$}`,[],(V)=>{});this.sai({meme:10})}}class g extends j{callbacks={};constructor($,V){super($,[],()=>{});this.callbacks=V,this.setProp("slotted_ability",!0)}onSlot($){if($.owner.addSlottedAbility(this),this.callbacks.onSlot)this.callbacks.onSlot($)}onUnslot($){if($.owner.removeSlottedAbility(this),this.callbacks.onUnslot)this.callbacks.onUnslot($)}playerEvents(){return this.callbacks.playerEvents??{}}clone(){let $=new g(this.text,this.callbacks);$.setFormula(this.formula),$.setCanPlay(this.canPlay.getCallback()),$.setCanGive(this.canGive.getCallback()),$.sai(this.ai());for(let V of Object.keys(this.props))$.setProp(V,this.props[V]);return $}}class e extends j{constructor($){super("Add {formula} turns",[],(V,J)=>{V.owner.addTurns(Math.max(0,this.calcFormula(V)))});this.setFormula(`1 + ${$} - {pow}`),this.sai({winProgress:(V)=>Math.max($-V.card.pow(),0),affectsSelf:(V)=>Math.max($-V.card.pow(),0)})}}var f;(function(K){K["UPGRADE_SHOP"]="meta_upgrade";K["RELIGION"]="meta_slottable_religion";K["CURRENCY"]="meta_currency"})(f||(f={}));class u extends j{constructor($){super("Draw {formula} cards",[],(V,J)=>{V.owner.draw(V.deck,this.calcFormula(V))});this.sai({drawsCards:(V)=>V.card.pow()+$}),this.setFormula(`{pow} + ${$}`)}}class a extends j{constructor($){super("Recover {formula} cards",(V)=>{return new Array($).fill({choice:z.CARD_IN_DISCARD,pointer:W.CARD_IN_DISCARD_MOST_POWER,distinct:!0})},(V,J)=>{while(J.length>0){if(V.deck.discardPile.length==0)break;J.pop().move(M.HAND,V)}});this.setCanPlay((V)=>{if(!V.deck)return!1;return V.deck.discardPile.length>=$}),this.sai({drawsCards:$}),this.setFormula(`${$}`)}}class o extends j{constructor($){super("Opponent discards {formula} cards",[{choice:z.OPPONENT,pointer:W.OPPONENT_MOST_CARDS}],(V,J)=>{let K=J[0],Q=this.calcFormula(V);if(K.cih().length<=Q)K.discardHand(V);for(let X=0;X<Q;X++){if(K.inHand()===0)break;K.discardChoose(V)}});this.sai({affectsOpponents:(V)=>this.calcFormula(V)/V.opps.length,discardsOpponentCards:(V)=>this.calcFormula(V)}),this.setFormula(`{pow} + ${$}`)}}class r extends j{constructor($){super("Remove {formula} turns.",[],(V,J)=>{V.owner.addTurns(-Math.max(0,this.calcFormula(V)))});this.setFormula(`${$} + {pow}`),this.sai({winProgress:(V)=>Math.max($+V.card.pow(),0),affectsSelf:(V)=>Math.max($+V.card.pow(),0)})}}class $0 extends j{constructor($){super("Opponent skips {formula} turns",[{choice:z.OPPONENT,pointer:W.OPPONENT_MOST_CARDS}],(V,J)=>{let K=J[0];for(let Q=0;Q<this.calcFormula(V);Q++)K.skip()});this.sai({affectsOpponents:$}),this.setFormula(`{pow} + ${$} - 1`)}}class V0 extends j{constructor($,V="{name}",J=z.CARD_IN_HAND){super(`Add "${$.getRawText()}" to a card in ${J===z.CARD_IN_HAND?"your hand":"the discard pile"}`,[{choice:J,pointer:J===z.CARD_IN_HAND?W.CARD_IN_HAND_RANDOM:W.CARD_IN_DISCARD_RANDOM}],(K,Q)=>{let X=Q[0],O=V.replace("{name}",X.getName());X.setName(O),X.addAbility($.clone().setFormula(`${$.getFormula()} - ${X.pow()}`))});this.setFormula(`${$.getFormula()} - 1`),this.sai($.ai())}}var L0={zombie_deck:[new N("Chomp",[new x,new j("Deal {formula} damage to an opponent. They discard that many cards.",[{pointer:W.OPPONENT_MOST_CARDS,choice:z.OPPONENT}],($,V)=>{let J=V[0],K=$.card.pow()*5;if($.owner.getProp("res_life")<=0){J.setProp("res_life",J.getProp("res_life")-K,$);for(let Q=0;Q<K;Q++)J.discardChoose($)}}).setFormula("{pow} * 5")]).setRarity(S.COMMON),new N("Brain Munchies",[new x,new j("Draw {formula} cards.",[],($,V)=>{if($.owner.getProp("res_life")<=0)$.owner.draw($.deck,$.card.pow())}).setFormula("{pow} + 2")]).setRarity(S.COMMON),new N("X-49 Antigen",[new j("Play only if you aren't an antivaxxer.",[],($,V)=>{}).setCanPlay(($)=>{return!$.owner.getProp("antivaxxer")}),new j("Heal all zombies. They give you their hands out of gratitude.",[],($,V)=>{if(!$.owner.getProp("antivaxxer"))for(let J of $.opps)J.setProp("res_life",10,$),$.owner.setCiH($.owner.cih().concat(J.cih())),J.setCiH([])})]).setCanPlay(($)=>{return!$.owner.getProp("antivaxxer")}).setRarity(S.RARE),new N("Necromutation",[new x,new i,new t(2)]).setRarity(S.RARE),new N("Rot Brains",[new x,new j("Zombify half the cards in an opponents hand. (They can't play them unless they are a zombie)",[{choice:z.OPPONENT,pointer:W.OPPONENT_MOST_CARDS}],($,V)=>{let J=V[0],K=J.cih(),Q=Math.ceil(K.length/2),X=K.map((O,F)=>O.clone()).sort(()=>Math.random()-0.5);for(let O=0;O<Q;O++)X[O]=new N(`Zombified ${X[O].getName()}`,[new x,...X[O].getAbilities()]).setPow(X[O].pow()).setRarity(X[O].getRarity()).setProps({zombie:!0,...X[O].getProps()}).setZone(M.HAND);J.setCiH(X)})])],faith_deck:[new N("Many-Armed One",[new m("faith_evangelical_deck",75,!0,!0).setText("Play only if the evangelical deck hasn't been added yet. Add the evangelical deck to the game."),new g("When you draw a card, gain 1 faith",{playerEvents:{draw:[($)=>{$.owner.addResource("faith",1)}]}}).setProp(f.RELIGION,[0])]).setRarity(S.BASIC),new N("Thoughts and Prayers",[new v(0,"faith"),new e(3).setText("Meditate. Add {formula} turns.")]).setRarity(S.COMMON),new N("Have You Heard the Good Message?",[new v(1,"faith"),new d(2).setText("Discard {formula} cards.")]).setRarity(S.COMMON)],poop_deck:[new N("Pile o' Crap",[new s("\uD83D\uDCA9")]).setRarity(S.BASIC).setProp("crap",!0)],basic:[new N("Consider",[new u(1)]).setRarity(S.COMMON),new N("Recover",[new a(1)]).setRarity(S.RARE),new N("Tickle",[new o(1)]).setRarity(S.COMMON),new N("Accelerate",[new r(2)]).setRarity(S.UNCOMMON),new N("Throat Punch",[new u(1),new o(1)]).setRarity(S.UNCOMMON),new N("Skip",[new $0(1)]).setRarity(S.MYTHIC),new N("Innovate",[new V0(new u(1),"Innovative {name}",z.CARD_IN_HAND)]).setRarity(S.COMMON),new N("You Could Make a Religion Outta This",[new m("faith_deck"),new v(1,"faith"),new j("Everyone unlocks the ability to create a religion",[],($)=>{for(let V of[$.owner,...$.opps])V.setProp("religion",!0,$)}),new c]).setRarity(S.LEGENDARY)]},C=L0;class q extends Array{constructor(){super(...arguments)}discardPile=[];props={};set($){return this.splice(0,this.length,...$),this}asArray(){return this}addCard($,V=1){for(let J=0;J<V;J++)this.push($.clone().setZone(M.DECK));return this}addCards($){return this.push(...$.map((V)=>V.clone().setZone(M.DECK))),this}shuffle(){for(let $=this.length-1;$>0;$--){const V=Math.floor(Math.random()*$),J=this[$];this[$]=this[V],this[V]=J}}reshuffle(){this.push(...this.discardPile.map(($)=>$.setZone(M.DECK))),this.discardPile=[],this.shuffle()}draw($=1){let V=[];for(let J=0;J<$;J++){if(this.length===0)this.reshuffle();V.push(this.pop().setZone(M.HAND))}return V}static fromCardList($,V){let J=C[V],K={};for(let F of J){if(!K[F.getRarity()])K[F.getRarity()]=0;K[F.getRarity()]++}let Q={},X=0;for(let F of Object.keys(K))Q[F]=$*Math.pow(0.75,Object.keys(K).indexOf(F)),X+=Q[F];for(let F of Object.keys(K))Q[F]=Math.round(Q[F]/X*$);let O=new q;for(let F of J)O.addCard(F.clone(),Q[F.getRarity()]);return O}}class J0{data;effect;infinite=!1;scale=1.1;constructor($,V,J=!1,K=1.1){if(this.data=JSON.parse(JSON.stringify($)),!this.data.level)this.data.level=0;this.effect=V,this.infinite=J,this.scale=K}lvl(){return this.data.level}getCost(){return this.data.cost}getData($){return{name:this.getName(),description:this.getDescription(),cost:this.getCost(),locked:this.data.locked||!this.canPayCost($),level:this.data.level}}getName(){return`${this.data.name}${this.infinite&&this.data.level>0?` Lvl. ${this.data.level}`:""}`}getDescription(){let $=this.data.description;$=$.replace("{level}",this.data.level+"");let V=$.match(/{[^}]*}/g);if(V)for(let J of V){let K=J.substring(1,J.length-1);$=$.replace(J,(0, eval)(K))}return $}canPayCost($){let V=$.owner.getResources();for(let J of this.data.cost){if(J.resource=="turns")continue;if(!V[J.resource])return!1;if(V[J.resource]<J.amt)return!1}return!0}payCost($){let V=$.owner.getResources();for(let J of this.data.cost)if(J.resource==="turns"){$.owner.addTurns(J.amt);continue}else $.owner.setProp(`res_${J.resource}`,V[J.resource]-J.amt,$)}locked(){return this.data.locked}unlock($){if(!this.data.locked)if(this.payCost($),this.effect($,this),this.data.level++,!this.infinite)this.data.locked=!0;else for(let V of this.data.cost)V.amt=Math.ceil(V.amt*this.scale)}}var P;(function(J){J[J["DISCARD_FROM_HAND"]=0]="DISCARD_FROM_HAND";J[J["GIVE_TO_CONTROLLER"]=1]="GIVE_TO_CONTROLLER"})(P||(P={}));class X0{structure=[];slots=[];addCard($,V=0){if(this.getValidTiers($.card).includes(V))return this.slots[V]=$.card,$.card.onSlottable($),!0;else if(this.isValid($.card)){for(let J of this.getValidTiers($.card))if(this.slots[J]===void 0)return this.slots[J]=$.card,$.card.onSlottable($),!0}return!1}}class K0 extends X0{name;props;constructor($){super();this.structure=[{name:"Foundation",slots:1},{name:"Pillars",slots:1},{name:"Doctrine",slots:1}],this.slots.fill(void 0,0,this.structure.length)}getValidTiers($){return $.getProp(f.RELIGION)??[]}addCard($,V=0){return super.addCard($,V)}getCards(){return this.slots}getCardsOfTier($){return[this.slots[$]]}getName(){return this.name}setName($){return this.name=$,this}getProp($){return this.props[$]}getProps(){return this.props}isValid($){return $.getProp(f.RELIGION)!==void 0&&$.getProp(f.RELIGION).filter((V)=>{return this.slots[V]===void 0}).length>0}setProp($,V,J){return this.props[$]=J?new _(V).resolve(J):V,this}toState($){return{name:this.name,props:this.props,structure:this.structure,slots:this.slots.map((V)=>{return V.toState($)}),validity:$.owner.cih().map((V)=>{return this.isValid(V)})}}}class E{name;cards=[];skipped=0;props={};events={};turnPlacement=0;turnsRemaining=25;canWin=!1;winReason="cards in hand";handSize=10;bot=!1;host=!1;botProfile=void 0;resolveBeforeTurn=[];slottedAbilities=[];eventList={};constructor($,V){this.name=Math.random().toString(36).substring(7),this.draw(V,$),this.setProp(f.UPGRADE_SHOP,[]),this.setProp(f.RELIGION,new K0("Da Faith")),this.addUpgrade(new J0({name:"Take a Crap",description:"Take a bathroom break to draw a card.",cost:[{amt:1,resource:"turns"}],locked:!1},(J)=>{J.owner.draw(J.deck,1),J.deck.addCards(q.fromCardList(1,"poop_deck"))},!0,1.5)),this.addEvent("draw",(J)=>{if(!J.card)return;if(!this.eventList[J.card.getName()])this.eventList[J.card.getName()]={drawn:0,played:0,discarded:0,given:0,text:""};J.card.fireEvents("draw",J),this.eventList[J.card.getName()].drawn++,this.eventList[J.card.getName()].text=J.card.getText()}),this.addEvent("play",(J)=>{if(!this.eventList[J.card.getName()])this.eventList[J.card.getName()]={drawn:0,played:0,discarded:0,given:0,text:""};this.eventList[J.card.getName()].played++,this.eventList[J.card.getName()].text=J.card.getText(),J.owner.addTurns(-1)}),this.addEvent("discard",(J)=>{if(!J.card)return;if(!this.eventList[J.card.getName()])this.eventList[J.card.getName()]={drawn:0,played:0,discarded:0,given:0,text:""};this.eventList[J.card.getName()].discarded++,this.eventList[J.card.getName()].text=J.card.getText()}),this.addEvent("give",(J)=>{if(!this.eventList[J.card.getName()])this.eventList[J.card.getName()]={drawn:0,played:0,discarded:0,given:0,text:""};this.eventList[J.card.getName()].given++,this.eventList[J.card.getName()].text=J.card.getText()}),this.addEvent("res_life_change",(J)=>{if(this.getProp("res_life")<=0){if(!J.deck)return;if(!J.deck.props.added_zombie_deck)J.deck.addCards(q.fromCardList(45,"zombie_deck")),J.deck.shuffle(),J.deck.props.added_zombie_deck=!0}})}addSlottedAbility($){return this.slottedAbilities.push($),this}removeSlottedAbility($){return this.slottedAbilities.splice(this.slottedAbilities.indexOf($),1),this}addResource($,V){if($.startsWith("res_"))$=$.substring(4);if(!this.getProp(`res_${$}`))this.setProp(`res_${$}`,0);this.setProp(`res_${$}`,this.getProp(`res_${$}`)+V)}upgrades(){return this.props[f.UPGRADE_SHOP]||[]}religion(){return this.props[f.RELIGION]||void 0}addUpgrade($){if(!this.props[f.UPGRADE_SHOP])this.props[f.UPGRADE_SHOP]=[];this.props[f.UPGRADE_SHOP].push($),this.fireEvents("new_upgrade",{owner:this,opps:[],deck:void 0,card:void 0})}setHost($=!0){return this.host=$,this}isHost(){return this.host}getResources(){let $={};for(let V in this.props)if(V.startsWith("res_"))$[V.substring(4)]=this.props[V];return $.turns=Infinity,$}getUIs(){return{upgrade:!0,religion:this.props.religion||!1}}getRelevantProps(){let $={};for(let V in this.props)if(!V.startsWith("meta_"))$[V]=this.props[V];return $}getPrivate($=!1){return{name:this.name,cards:this.cards.length,handsize:this.handSize,skipped:this.skipped,props:this.getRelevantProps(),turnsRemaining:this.turnsRemaining,canWin:this.canWin,winReason:this.winReason,host:this.host,you:$,order:this.turnPlacement,interrupts:this.resolveBeforeTurn}}getCards($,V){return this.cards.map((J)=>J.toState({owner:this,opps:$,deck:V,card:J}))}setBot(){return this.bot=!0,this.botProfile=new w(Object.keys(T)[Math.floor(Math.random()*Object.keys(T).length)]),this}isBot(){return this.bot}setName($){return this.name=$,this}getCardStats(){return this.eventList}setTurnPlacement($){return this.turnPlacement=$,this}getTurnPlacement(){return this.turnPlacement}getHandsize(){return this.handSize}getBotProfile(){return this.botProfile}addHandsize($){return this.handSize+=$,this}setHandsize($){return this.handSize=$,this}propList(){return this.props}on($,V){return this.addEvent($,V),this}addEvent($,V){if(!this.events[$])this.events[$]=[];this.events[$].push(V)}getWinReason(){return this.winReason}fireEvents($,V){if(this.events[$])for(let J of this.events[$])J(V);if(this.events[`temp_${$}`]){for(let J of this.events[`temp_${$}`])J(V);delete this.events[`temp_${$}`]}for(let J of this.slottedAbilities){let K=J.playerEvents();if(K[$])for(let Q of K[$])Q(V)}}addTurns($){if(this.turnsRemaining+=$,this.turnsRemaining<=0)this.setCanWin(!0,"plodded across the finish line");return this}setTurns($){return this.turnsRemaining=$,this}getTurns(){return this.turnsRemaining}rollDice(){if(this.getProp("dice")){let $=this.getProp("dice");return $[Math.floor(Math.random()*$.length)]}return-1}setCanWin($,V="cards in hand"){if(this.canWin=$,this.winReason=V,this.canWin)this.fireEvents("can_win",{owner:this,opps:[],card:void 0,deck:void 0});return this}winCheck(){return this.canWin}setProp($,V,J){if(this.props[$]=V,J)this.fireEvents(`${$}_change`,J);return this}getProps(){return this.props}getProp($){return this.props[$]||0}skip(){this.skipped++}skipCheck(){if(this.skipped>0)return this.skipped--,!0;return!1}toPlayerState(){return{name:this.name,cards:this.cards.length,handsize:this.handSize,skipped:this.skipped,props:this.props,turnsRemaining:this.turnsRemaining,canWin:this.canWin,winReason:this.winReason,host:this.host,you:!1,order:this.turnPlacement,interrupts:this.resolveBeforeTurn}}getLogText(){return`\xA7\xA7${this.bot?`<b>[${this.botProfile.getProfileName()}]</b> `:""}${this.host?"<b>[HOST]</b> ":""}${this.name}\xA7player\xA7${JSON.stringify(this.toPlayerState())}\xA7\xA7`}getName(){return this.name}cih(){return this.cards}setCiH($){return this.cards=$,this}inHand(){return this.cards.length}turnStart($){for(let V of this.cards)V.fireEvents("turn_start",{...$,card:V})}draw($,V=1){let J=$.draw(V);for(let K of J){if(!K)continue;if(K.draw(this,[],$),this.fireEvents("draw",{owner:this,opps:[],deck:$,card:K}),V>=1)this.cards=this.cards.concat(K)}}play($,V,J,K){if(this.cards.splice(this.cards.indexOf($),1),!$.doSkipDiscard())J.discardPile.push($.setZone(M.DISCARD));else $.remove({card:$,deck:J,owner:this,opps:V});$.play(this,V,J,K),this.fireEvents("play",{owner:this,opps:V,deck:J,card:$})}give($,V){$.give(this,[V],void 0),this.fireEvents("give",{owner:this,opps:[],deck:void 0,card:$}),V.cards.push($),this.cards.splice(this.cards.indexOf($),1)}discard($,V){$.discard(this,[],V),this.fireEvents("discard",{owner:this,opps:[],deck:V,card:$}),V.discardPile.push($.setZone(M.DISCARD)),this.cards.splice(this.cards.indexOf($),1)}discardRandom($){let V=this.cih()[Math.floor(Math.random()*this.cih().length)];if(V)this.discard(V,$.deck)}discardHand($){while(this.cih().length>0)this.discardRandom($)}giveChoose($){if(this.isBot())this.give(this.weightedGive($),$.opps[0]);else this.resolveBeforeTurn.push(P.GIVE_TO_CONTROLLER)}discardChoose($){if(this.isBot()){let V=this.weightedDiscard($);if(V)this.discard(V,$.deck);else this.discardRandom($)}else this.resolveBeforeTurn.push(P.DISCARD_FROM_HAND)}hasInterrupts(){return this.resolveBeforeTurn.length>0}getInterrupts(){return this.resolveBeforeTurn}clearInterrupts(){return this.resolveBeforeTurn=[],this}randomCard(){return this.cards[Math.floor(Math.random()*this.cards.length)]}weightedDiscard($){let V=Infinity,J=null;for(let K of this.cards)if(K&&this.isBot()){let Q=this.botProfile.evaluate(K,$);if(Q<V*(0.8+Math.random()*0.4))V=Q,J=K}return J}weightedDiscardToHand($){if(this.cih().length>this.getHandsize())while(this.cih().length>this.getHandsize()){let V=this.weightedDiscard($);if(V||!$.deck)this.discard(V,$.deck);else return}}weightedGive($){let V=Infinity,J=null;for(let K of this.cards)if(K&&this.isBot()){let Q=this.botProfile.evaluate(K,$);if(Q<V*(0.8+Math.random()*0.4))V=Q,J=K}return J}weightedPlay($){let V=(-Infinity),J=null;for(let K of this.cards)if(K&&this.botProfile){let Q=this.botProfile.evaluate(K,$);if(Q>V*(0.8+Math.random()*0.4)&&K.canBePlayed($))V=Q,J=K}else console.log("not a bot");return J}getEvent($){return this.events[$]}removeEvent($){return delete this.events[$],this}selectChoices($,V){return[]}evaluate($,V){return 0}}var H;(function(U){U[U["CONNECTED"]=0]="CONNECTED";U[U["DISCONNECTED"]=1]="DISCONNECTED";U[U["SET_NAME"]=2]="SET_NAME";U[U["UPDATE_PLAYER_STATE"]=3]="UPDATE_PLAYER_STATE";U[U["SERVER_MSG"]=4]="SERVER_MSG";U[U["SEND_LOG"]=5]="SEND_LOG";U[U["ADD_BOT"]=6]="ADD_BOT";U[U["KICK_PLAYER"]=7]="KICK_PLAYER";U[U["TRANSFER_UPGRADE_SHOP"]=8]="TRANSFER_UPGRADE_SHOP";U[U["BUY_UPGRADE"]=9]="BUY_UPGRADE";U[U["TRANSFER_MARKETPLACE"]=10]="TRANSFER_MARKETPLACE";U[U["TRANSFER_RELIGION"]=11]="TRANSFER_RELIGION";U[U["ADD_RELIGIOUS_TENANT"]=12]="ADD_RELIGIOUS_TENANT";U[U["CREATE_RELIGION"]=13]="CREATE_RELIGION";U[U["DRAW_CARD"]=14]="DRAW_CARD";U[U["PLAY_CARD"]=15]="PLAY_CARD";U[U["GIVE_CARD"]=16]="GIVE_CARD";U[U["DISCARD_TO_HAND"]=17]="DISCARD_TO_HAND";U[U["GET_CHOICES"]=18]="GET_CHOICES";U[U["CHOICE_LIST"]=19]="CHOICE_LIST";U[U["PLAY_PHASE_CONFIRM"]=20]="PLAY_PHASE_CONFIRM";U[U["SEND_INTERRUPTS"]=21]="SEND_INTERRUPTS";U[U["RESOLVE_INTERRUPT"]=22]="RESOLVE_INTERRUPT";U[U["ERROR"]=23]="ERROR"})(H||(H={}));import{WebSocketServer as M0} from"ws";function U0($=100,V=!0){let J=[],K={},Q=0,X=100;for(let O=X;O>0;O--){let F=q.fromCardList(300,"basic"),Y=[];for(let G=0;G<3+X%3;G++)Y.push(new E(7,F).setBot());for(let G of Object.values(C))J.push(...G.map((B)=>B.clone()));for(let G of J)for(let B=0;B<Y.length;B++){let h={owner:Y[B],opps:Y.filter((R,Q0)=>Q0!==B),card:G},p=G.getTraits(h).profile;for(let R in p){if(!K[R])K[R]=0;K[R]+=p[R]}Q++}if(V)console.log(`${O} simulation${O>1?"s":""} remaining... (${Q} iterations)`)}for(let O in K)K[O]/=Q,K[O]=1/K[O];if(V)console.log(K);return K}class b{players={};sockets={};deck;turnPhase=0;activeTurn="";logEntries=[];sendableLogs=[];serverObj=void 0;serverPort=15912;serverConfig={startingHand:4,maxPlayers:6,minPlayers:1,fairness:!0};booted=!1;constructor(){this.deck=q.fromCardList(60,"basic"),this.deck.shuffle()}reset(){if(this.serverObj)this.serverObj.close();this.deck=q.fromCardList(60,"basic"),this.deck.shuffle(),this.sockets={},this.players={},this.turnPhase=0,this.activeTurn="",this.sendableLogs=[],this.log("Server reset!"),this.init(this.serverPort)}static createName(){return[["Cheddar","Swiss","Sewer","Moist","Crusty","Crunchy","Crispy","Bam","Bang","Slam","Meow","Bark","Grand","Del","Dip","Rich","Povert","Rogue","Joleto","Tad","Italian","Spicy","Salty","Sweet","Sour","Bitter","Stinky","Irritating","Meaty","Cool","Neato","Awesome","Sassy"],["amole","lotion","bacon","slice","sliver","fluid","ian","jess","tad","Loaf","Crust","Crunch","Crisp","Ioli","Head","Ino","Pants","Zilla","Shirt","Shoes","Hat","Glove","Sock","Spaghetti","Oritto","Ravioli","Gnocchi","Chilada","Pierogi","Burrito","Taco","Enchilada","Tamale","Changa","Dilla","Nachos","Tilla","Chip","Salsa","Guacamole","Asaurus","Eratops"],[" Mc"," "," "," "," "," "," "," "," Mac"," O'"],["Pan","Tad","Crap","Gene","Friendly","Spicy","Hate","Spinach","Slam","Magic","Eraser","Bougie","Ball","Supremo","Bean","Burger","Bread","Biscuit","Bacon","Bun","Biscuit","Burger","Bread","Kitty","Wood","Morning","Soft","Hard","Raging","",""],["Plumbing","Orama","Adic","Tastic","Full","Loaf","Fruit","Table","Chair","Brian","Brain","Atomy","Acist","Ologist","Doofus","Dorkus","Itis","Person","Biden","Trump","Obama","Bush","Clinton","Reagan","Carter","Folk","Ford","Sandal","Muncher","Potato","Whiskey","Bourbon"]].map((V,J)=>{let K=V[Math.floor(Math.random()*V.length)];if(J>0&&!K.startsWith(" "))K=K.toLowerCase();return K}).join("").split(" ").map((V)=>V[0].toUpperCase()+V.substring(1).toLowerCase()).join(" ")}log($){console.log($),this.logEntries.push($.toString())}gameLog($){this.sendableLogs.push($);for(let V of Object.values(this.sockets))V.send(JSON.stringify({type:H.SEND_LOG,log:$}))}getDeck(){return this.deck}addPlayer(){if(this.serverConfig.fairness)Object.values(this.players).forEach((V)=>V.addTurns(1));let $=Math.random().toString(36).substring(7);if(this.players[$]=new E(this.serverConfig.startingHand,this.deck).setTurnPlacement(Object.keys(this.players).length),this.players[$].addEvent("new_upgrade",(V)=>{this.updateUpgradeShop($)}),this.activeTurn==="")this.activeTurn=$,this.players[$].setHost();return{id:$,index:Object.keys(this.players).length-1}}addBot(){if(this.serverConfig.fairness)Object.values(this.players).forEach((V)=>V.addTurns(1));let $=Math.random().toString(36).substring(7);return this.players[$]=new E(this.serverConfig.startingHand,this.deck).setTurnPlacement(Object.keys(this.players).length).setName(b.createName()).setBot(),this.gameLog(`${this.players[$].getLogText()} joined the game as a bot.`),$}incrementPhase(){let $=!0;for(let X of Object.keys(this.players))if(this.players[X].hasInterrupts()&&!this.players[X].isBot())this.sockets[X].send(JSON.stringify({type:H.SEND_INTERRUPTS,interrupts:this.players[X].getInterrupts()})),$=!1;if(!$)return this.updateAllStates(),!1;let V={owner:this.getActive(),opps:Object.values(this.players).filter((X)=>X!==this.getActive()),deck:this.deck},J=Object.keys(this.players).length>=2&&this.getActive().cih().length>=2&&this.getActive().cih().some((X)=>X.canBeGiven(this.getActive(),{...V,card:X})),K=this.getActive().cih().some((X)=>X.canBePlayed({owner:this.getActive(),opps:Object.values(this.players).filter((O)=>O!==this.getActive()),deck:this.deck,card:X}))||this.getActive().getProp("meta_upgrade").some((X)=>{return X.getData(V)}),Q=this.getActive().cih().length>this.getActive().getHandsize();if(this.turnPhase===0)if(J)this.turnPhase=1;else if(K)this.turnPhase=2;else if(Q)this.turnPhase=3;else this.incrementTurn();else if(this.turnPhase===1)if(K)this.turnPhase=2;else if(Q)this.turnPhase=3;else this.incrementTurn();else if(this.turnPhase===2)if(Q)this.turnPhase=3;else this.incrementTurn();this.updateAllStates()}incrementTurn(){if(this.gameLog(`${this.getActive().getLogText()} ended their turn.`),this.gameLog("===NEW TURN==="),this.turnPhase=0,Object.values(this.players).length==0)this.activeTurn="",this.updateAllStates();else if(this.activeTurn=Object.keys(this.players)[(Object.keys(this.players).indexOf(this.activeTurn)+1)%Object.keys(this.players).length],this.gameLog(`${this.getActive().getLogText()} begins their turn.`),this.updateAllStates(),this.getActive().skipCheck())this.gameLog(`${this.getActive().getLogText()} is skipped.`),this.incrementTurn();else if(this.getActive().isBot())this.playBotTurn()}playBotTurn(){let $=Object.keys(this.players).filter((Q)=>Q!==this.activeTurn).map((Q)=>this.players[Q]),V={owner:this.getActive(),opps:$,deck:this.deck};this.getActive().draw(this.deck,1),this.gameLog(`${this.getActive().getLogText()} draws a card.`);let J=null;try{J=this.getActive().cih().filter((Q)=>Q.canBePlayed({...V,card:Q}))}catch(Q){this.gameLog(`${this.getActive().getLogText()} has an error in their hand: ${Q}`)}if(this.turnPhase=1,this.updateAllStates(),this.getActive().cih().length>=2){let Q=this.getActive().weightedGive(V);if(Q){let X=$[Math.floor(Math.random()*$.length)];this.gameLog(`${this.getActive().getLogText()} gives ${Q.getLogText()} to ${X.getLogText()}.`),this.getActive().give(Q,X)}}else this.gameLog(`${this.getActive().getLogText()} doesn't have enough cards to be generous.`);let K=J.length>0;if(K)this.turnPhase=2;else this.turnPhase=3;if(this.updateAllStates(),K){let Q=this.getActive().weightedPlay(V);if(Q)this.gameLog(`${this.getActive().getLogText()} plays ${Q.getLogText()}.`),this.getActive().play(Q,$,this.deck);this.turnPhase=3,this.updateAllStates()}this.getActive().weightedDiscardToHand(V),this.incrementTurn()}updateReligion($){if(this.players[$].religion())this.sockets[$].send(JSON.stringify({type:H.TRANSFER_RELIGION,religion:this.players[$].religion().toState({owner:this.players[$],opps:[],deck:this.deck})}))}updateUpgradeShop($){this.sockets[$].send(JSON.stringify({type:H.TRANSFER_UPGRADE_SHOP,shop:this.players[$].getProp("meta_upgrade").map((J)=>{return J.getData({owner:this.players[$],opps:[],deck:this.deck})})}))}disconnect($,V=""){for(let J of this.players[$].cih())this.deck.discardPile.push(J);if($===this.activeTurn)this.incrementTurn();if(this.log(`Player ${$} disconnected (${this.players[$].getLogText()}) - ${V}`),this.gameLog(`${this.players[$]} disconnected.`),this.sockets[$])this.sockets[$].send(JSON.stringify({type:H.SERVER_MSG,message:V})),this.sockets[$].send(JSON.stringify({type:H.DISCONNECTED}));if(delete this.players[$],delete this.sockets[$],this.serverConfig.fairness)Object.values(this.players).forEach((J)=>J.addTurns(-1));if(Object.keys(this.players).length>0){let J=Object.keys(this.players).find((K)=>!this.players[K].isBot());if(J)this.players[J].setHost(),this.gameLog(`${this.players[J]} is now the host.`);else this.log("No non-bots left, server entering reset mode"),this.reset()}if(Object.keys(this.players).length===0)this.activeTurn="",this.log("No non-bots left, server entering reset mode"),this.reset();this.updateAllStates()}getActive(){if(this.activeTurn==="")throw new Error("No active turn");return this.players[this.activeTurn]}sendState($){let V=Object.keys(this.players).filter((Q)=>Q!==$).map((Q)=>this.players[Q]),J=Object.keys(this.players).indexOf(this.activeTurn),K=Object.keys(this.players).indexOf($);if(this.players[$].isBot())return;this.sockets[$].send(JSON.stringify({type:H.UPDATE_PLAYER_STATE,state:{game:{players:Object.values(this.players).map((Q,X)=>Q.getPrivate(X===K)),turnPhase:this.turnPhase,uis:this.players[$].getUIs(),activeTurn:J,deck:this.deck.length,config:this.serverConfig,discard:this.deck.discardPile.map((Q)=>({name:Q.getDisplayName(),text:Q.getFormulatedText({owner:this.players[$],opps:V,deck:this.deck,card:Q}),rarity:Q.getRarity(),props:Q.getProps()}))},personal:this.players[$].getCards(V,this.deck)}}))}updateAllStates(){Object.keys(this.players).forEach(($)=>this.sendState($))}adjustAIHeuristics($=250){console.log("Adjusting AI heuristics...");let V=U0($,!1);for(let J of Object.keys(T)){console.log(`\n=== ${J} ===`);for(let K of Object.keys(V))if(T[J][K]){let Q=Math.round(T[J][K]*V[K]*100)/100;console.log(`${K}: ${T[J][K]} -> ${Q}`),T[J][K]=Q}}}init($=15912){let V=this;if(V.log(`Server initialized on port ${$}`),this.serverPort=$,!this.booted)this.adjustAIHeuristics();this.booted=!0,this.serverObj=new M0({port:$}),this.serverObj.on("connection",function J(K){K.on("message",function X(O){let F=JSON.parse(O),Y=F.id,G=Object.keys(V.players).filter((B)=>B!==Y).map((B)=>V.players[B]);switch(F.type){case H.SET_NAME:if(F.name.length<1)F.name=b.createName();V.players[Y].setName(F.name),V.gameLog(`${V.players[Y].getLogText()} joined the game`),V.updateAllStates();break;case H.DRAW_CARD:if(V.activeTurn==Y&&V.turnPhase==0)V.players[Y].draw(V.deck,1),V.gameLog(`${V.players[Y].getLogText()} drew a card.`),V.incrementPhase();else if(V.activeTurn!==Y)K.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not your turn."}));else K.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not the draw phase."}));V.updateAllStates();break;case H.GIVE_CARD:let B=F.idInHand,h=Object.keys(V.players)[F.target];if(V.activeTurn==Y&&V.turnPhase==1&&h!==Y&&V.players[Y].cih().length>=2&&V.players[Y].cih()[B].canBeGiven(V.players[h],{card:V.players[Y].cih()[B],owner:V.players[Y],opps:G,deck:V.deck}))V.gameLog(`${V.players[Y].getLogText()} gives ${V.players[Y].cih()[B].getLogText()} to ${V.players[h].getLogText()}.`),V.players[Y].give(V.players[Y].cih()[B],V.players[h]),V.incrementPhase();else if(V.activeTurn===Y)K.send(JSON.stringify({type:H.ERROR,message:"This card can't be gifted - not your turn."}));else if(V.turnPhase!==1)K.send(JSON.stringify({type:H.ERROR,message:"This card can't be gifted - not the give phase."}));else if(V.players[Y].cih().length<2)V.gameLog(`${V.players[Y].getLogText()} doesn't have enough cards to be generous.`),V.incrementPhase();else K.send(JSON.stringify({type:H.ERROR,message:"This card can't be gifted - not giveable to this player."}));break;case H.GET_CHOICES:let p=F.idInHand,R=V.players[Y].cih()[p];if(R.canBePlayed({owner:V.players[Y],opps:G,deck:V.deck,card:R})&&V.activeTurn===Y&&V.turnPhase==2){let U=JSON.stringify({type:H.CHOICE_LIST,card:p,splits:R.getAbilities().map((I)=>I.getChoices().length),choices:R.getChoices({owner:V.players[Y],opps:G,deck:V.deck,card:R})});K.send(U)}else if(V.activeTurn===Y)K.send(JSON.stringify({type:H.ERROR,message:"This card can't have choices selected - not your turn."}));else if(V.turnPhase!==2)K.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not the play phase."}));else K.send(JSON.stringify({type:H.ERROR,message:"This card can't be played"}));break;case H.PLAY_CARD:let Q0=F.idInHand,Z=V.players[Y].cih()[Q0],Y0=F.choices,L=Y0.map((U,I)=>{let D=Z.orderAbilities()[I];return U.map((n,j0)=>{switch(D.informChoices({owner:V.players[Y],opps:G,deck:V.deck,card:Z})[j0].choice){case z.OPPONENT:case z.PLAYER:return V.players[Object.keys(V.players)[n]];case z.CARD_IN_HAND:return V.players[Y].cih()[n];case z.CARD_IN_DISCARD:return V.deck.discardPile[n]}})});if(V.activeTurn===Y&&V.turnPhase==2&&Z.canBePlayed({owner:V.players[Y],opps:G,deck:V.deck,card:Z})){let U={owner:V.players[Y],opps:G,deck:V.deck,card:Z};if(Z.getChoices(U).length>0)V.gameLog(`${V.players[Y].getLogText()} plays ${Z.getLogText()} with the following choices:\n${Y0.map((I,D)=>`${Z.orderAbilities()[D].getFormulatedText(U)}: ${L[D].map((n)=>n.getLogText()).join(", ")}`).join("\n")}`);else V.gameLog(`${V.players[Y].getLogText()} plays ${Z.getLogText()}.`);V.players[Y].play(Z,G,V.deck,L),V.incrementPhase()}else if(V.activeTurn===Y)K.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not your turn."}));else if(V.turnPhase!==2)K.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not the play phase."}));else K.send(JSON.stringify({type:H.ERROR,message:"This card can't be played - not playable."}));break;case H.DISCARD_TO_HAND:let H0=F.idInHand;if(V.activeTurn!==Y)K.send(JSON.stringify({type:H.ERROR,message:"This card can't be discarded - not your turn."}));else if(V.turnPhase!==3)K.send(JSON.stringify({type:H.ERROR,message:"This card can't be discarded - not the discard phase."}));else if(V.players[Y].cih().length<V.players[Y].getHandsize())K.send(JSON.stringify({type:H.ERROR,message:"This card can't be discarded - you don't have enough cards in hand."})),V.updateAllStates(),V.incrementTurn();else for(let U of H0)if(V.players[Y].cih().length>=U+1){let I=[V.players[Y].cih()[U]];V.players[Y].setCiH(V.players[Y].cih().filter((D)=>!I.includes(D)));for(let D of I)V.deck.discardPile.push(D);if(V.players[Y].cih().length<=V.players[Y].getHandsize())break;else V.updateAllStates()}break;case H.ADD_BOT:if(V.players[Y].isHost())V.addBot(),V.updateAllStates();else K.send(JSON.stringify({type:H.ERROR,message:"You can't add a bot - you aren't the host."}));break;case H.KICK_PLAYER:if(V.players[Y].isHost()){let U=F.target,I=Object.keys(V.players)[U];if(I===Y)K.send(JSON.stringify({type:H.ERROR,message:"You can't kick yourself."}));else V.gameLog(`${V.players[Y]} kicked ${V.players[I]}.`),V.disconnect(I,F.message??"The host hated your guts.")}else K.send(JSON.stringify({type:H.ERROR,message:"You can't kick a player - you aren't the host."}));break;case H.TRANSFER_UPGRADE_SHOP:if(V.getActive().getUIs().upgrade)V.updateUpgradeShop(Y);else K.send(JSON.stringify({type:H.ERROR,message:"You haven't unlocked the upgrade shop."}));break;case H.TRANSFER_RELIGION:if(V.players[Y].getUIs().religion)V.updateReligion(Y);else K.send(JSON.stringify({type:H.ERROR,message:"You haven't unlocked religion yet."}));break;case H.ADD_RELIGIOUS_TENANT:let A=F.idInHand;if(V.players[Y].cih().length<A+1||!V.players[Y].cih()[A])K.send(JSON.stringify({type:H.ERROR,message:"You can't add this tenant - invalid tenant."}));else if(!V.players[Y].getUIs().religion)K.send(JSON.stringify({type:H.ERROR,message:"You haven't unlocked religion yet."}));else if(!V.players[Y].religion())K.send(JSON.stringify({type:H.ERROR,message:"You don't have a religion."}));else if(V.players[Y].religion().isValid(V.players[Y].cih()[A]))V.players[Y].religion().addCard({owner:V.players[Y],opps:G,deck:V.deck,card:V.players[Y].cih()[A].clone()}),V.players[Y].setCiH(V.players[Y].cih().filter((U)=>U!==V.players[Y].cih()[A])),V.updateReligion(Y),V.incrementPhase();break;case H.RESOLVE_INTERRUPT:let F0=V.players[Y].getInterrupts(),y=F.interrupts;if(y.length!==F0.length)K.send(JSON.stringify({type:H.ERROR,message:"You can't resolve these interrupts - invalid number of interrupts."}));else{let U=[],I=[];for(let D=0;D<y.length;D++)switch(F0[D]){case P.DISCARD_FROM_HAND:if(V.players[Y].cih().length>0)U.push(V.players[Y].cih()[y[D]]);break;case P.GIVE_TO_CONTROLLER:if(V.players[Y].cih().length>0&&V.players[Y].cih()[y[D]])I.push(V.players[Y].cih()[y[D]]);break}U.forEach((D)=>{V.players[Y].discard(D,V.deck)}),I.forEach((D)=>{V.players[Y].give(D,V.getActive())}),V.players[Y].clearInterrupts()}V.incrementPhase();break;case H.BUY_UPGRADE:let k=F.upgrade,l=V.getActive().getProp("meta_upgrade");if(V.activeTurn!==Y)K.send(JSON.stringify({type:H.ERROR,message:"You can't buy an upgrade - not your turn."}));else if(!V.getActive().getUIs().upgrade)K.send(JSON.stringify({type:H.ERROR,message:"You can't buy an upgrade - you haven't unlocked the upgrade shop."}));else if(V.turnPhase!==2)K.send(JSON.stringify({type:H.ERROR,message:"You can't buy an upgrade - not the play phase."}));else if(l.length<=k||k<0||l[k].locked()||!l[k].canPayCost({owner:V.getActive(),opps:G,deck:V.deck}))K.send(JSON.stringify({type:H.ERROR,message:"You can't buy an upgrade - invalid upgrade."}));else l[k].unlock({owner:V.getActive(),opps:G,deck:V.deck}),V.gameLog(`${V.getActive().getLogText()} bought ${l[k].getData({owner:V.getActive(),opps:G,deck:V.deck}).name}.`),V.incrementPhase(),V.updateAllStates(),V.updateUpgradeShop(Y);break}}),K.on("close",function X(O,F){let Y=Object.keys(V.sockets).find((G)=>V.sockets[G]===K);V.disconnect(Y)});let Q=V.addPlayer();V.sockets[Q.id]=K,K.send(JSON.stringify({type:H.CONNECTED,connected:Q.id,host:Object.keys(V.players)[0]==Q.id,turn:Q.index}))})}}var W0=new b;W0.init(15912);
